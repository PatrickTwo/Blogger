
## 一、集合（set）
在C++中，主要的集合类有 `set`、`multiset`、`unordered_set`、`unordered_multiset`。以下是它们的常用操作：

#### 基本声明

```cpp
#include <set>           // set, multiset
#include <unordered_set> // unordered_set, unordered_multiset
#include <iostream>
using namespace std;

// 基本声明
set<int> s1;                    // 有序，不允许重复
multiset<int> ms1;              // 有序，允许重复
unordered_set<int> us1;         // 无序，不允许重复
unordered_multiset<int> ums1;   // 无序，允许重复
```

### 1. 插入
`insert` 方法用于向集合中插入元素。

```cpp
// 插入单个元素
set.insert(30);
// 插入多个元素（C++11）
et.insert({40, 50, 60});
```

### 2. 删除
`erase`方法用于删除集合中的元素。

```cpp
// 按值删除
s.erase(30);  // 删除值为30的元素

// 按迭代器删除
auto it = s.find(20);
if (it != s.end()) {
    s.erase(it);  // 删除迭代器指向的元素
}

// 删除一段区间
auto start = s.find(10);
auto end = s.find(40);
if (start != s.end() && end != s.end()) {
    s.erase(start, end);  // 删除[10, 40)区间的元素
}
```

:::warning
当调用`erase()`方法时，删除元素后，集合的迭代器会失效，不会自动将迭代器设置为 end() 或其他有效值。
:::

### 3. 查找
```cpp
set<int> s = {10, 20, 30, 40, 50};

// 使用 find() - 所有集合都支持
auto it_s = s.find(30);

// 使用 count() - 返回元素出现的次数
cout << "set中10的个数: " << s.count(10) << endl;    // 1

// multiset/multiset 特有：lower_bound, upper_bound, equal_range
multiset<int> ms = {10, 20, 20, 30, 30, 30, 40};

auto lb = ms.lower_bound(25);  // 第一个 >= 25 的元素
auto ub = ms.upper_bound(30);  // 第一个 > 30 的元素
```
:::hint
对于`multiset`集合，通过`find`方法只能找到第一个匹配的元素的迭代器。如果需要找到所有匹配的元素，需要使用`equal_range`方法。
:::

### 4. 遍历

```cpp
set<int> s = {30, 10, 20, 40, 50};  // 自动排序

// 方法1：范围for循环
for (int num : s) {
    cout << num << " ";
}

// 方法2：迭代器
for (auto it = s.begin(); it != s.end(); ++it) {
    cout << *it << " ";
}

// 方法3：反向迭代器
for (auto it = s.rbegin(); it != s.rend(); ++it) {
    cout << *it << " ";
}

// 方法4：while循环
auto it = s.begin();
while (it != s.end()) {
    cout << *it << " ";
    ++it;
}
```

### 5. 集合运算（针对set）

```cpp
set<int> s1 = {1, 2, 3, 4, 5};
set<int> s2 = {4, 5, 6, 7, 8};
set<int> result;

// 并集
set_union(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(result, result.begin()));

// 交集
set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(result, result.begin()));

// 差集
set_difference(s1.begin(), s1.end(), s2.begin(), s2.end(), inserter(result, result.begin()));
```

## 二、vector
`std::vector` 是C++标准模板库(STL)中最重要、最常用的容器之一，它是一个**动态数组**，能够自动管理内存大小。

#### 特点
- **动态大小**：可以在运行时改变大小
- **连续存储**：元素在内存中连续存放，支持随机访问
- **自动内存管理**：自动处理内存分配和释放
- **类型安全**：模板类，提供类型安全的接口

#### 头文件
```cpp
#include <vector>
using namespace std; // 或者 using std::vector;
```

### 1. vector的声明与初始化

#### 基本声明
```cpp
vector<int> v1;                    // 空vector
vector<int> v2(5);                 // 5个元素的vector，默认值为0
vector<int> v3(5, 10);             // 5个元素，每个都是10
vector<int> v4{1, 2, 3, 4, 5};     // 初始化列表(C++11)
vector<int> v5 = {1, 2, 3, 4, 5};  // 同上
```

#### 从其他容器初始化
```cpp
vector<int> v6(v4);                // 拷贝构造
vector<int> v7(v4.begin(), v4.end()); // 迭代器范围
int arr[] = {1, 2, 3, 4, 5};
vector<int> v8(arr, arr + 5);      // 从数组初始化
```

### 2. vector的核心操作

#### 容量相关操作
```cpp
vector<int> vec = {1, 2, 3, 4, 5};

cout << vec.size();      // 元素个数：5
cout << vec.capacity();  // 当前容量：通常>=size
cout << vec.empty();     // 是否为空：false
cout << vec.max_size();  // 最大可能元素数

vec.resize(10);          // 调整大小为10，新增元素默认0
vec.resize(3);           // 调整大小为3，多余元素被删除
vec.reserve(20);         // 预分配容量，不改变size
vec.shrink_to_fit();     // 减少capacity到等于size(C++11)
```

#### 元素访问
```cpp
vector<int> vec = {10, 20, 30, 40, 50};

// 下标访问（不检查边界）
cout << vec[2];          // 30
vec[1] = 25;             // 修改元素

// at()方法（检查边界，越界抛出异常）
cout << vec.at(2);       // 30
// vec.at(10);           // 抛出std::out_of_range异常

// 首尾元素
cout << vec.front();     // 10
cout << vec.back();      // 50

// 数据指针（用于C风格API）
int* data = vec.data();
```

#### 修改操作
```cpp
vector<int> vec;

// 添加元素
vec.push_back(10);       // 尾部添加
vec.emplace_back(20);    // C++11，直接在尾部构造（更高效）
vec.insert(vec.begin(), 5); // 在开头插入5

// 删除元素
vec.pop_back();          // 删除尾部元素
vec.erase(vec.begin());  // 删除第一个元素
vec.erase(vec.begin(), vec.begin() + 2); // 删除前两个元素
vec.clear();             // 清空所有元素

// 赋值操作
vector<int> other = {1, 2, 3};
vec.assign(other.begin(), other.end()); // 重新赋值
vec = {6, 7, 8, 9};      // 使用初始化列表赋值
```

### 3. 遍历vector

#### 传统for循环
```cpp
vector<int> vec = {1, 2, 3, 4, 5};

// 下标遍历
for (size_t i = 0; i < vec.size(); i++) {
    cout << vec[i] << " ";
}

// 迭代器遍历
for (auto it = vec.begin(); it != vec.end(); ++it) {
    cout << *it << " ";
}
```

#### 现代C++遍历方式
```cpp
vector<int> vec = {1, 2, 3, 4, 5};

// 范围for循环(C++11)
for (int val : vec) {
    cout << val << " ";
}

// 只读范围for循环
for (const int& val : vec) {  // 避免拷贝，提高效率
    cout << val << " ";
}

// 使用auto
for (auto val : vec) {
    cout << val << " ";
}
```

### 5. 二维vector（vector数组）

#### 声明与初始化
```cpp
// 方法1：直接初始化
vector<vector<int>> matrix = {
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9}
};

// 方法2：指定行列
vector<vector<int>> mat1(3, vector<int>(4));     // 3x4，全0
vector<vector<int>> mat2(2, vector<int>(3, 5)); // 2x3，全5

// 方法3：逐行构建
vector<vector<int>> mat3;
mat3.resize(3, vector<int>(4));
```

#### 二维vector操作
```cpp
vector<vector<int>> matrix(3, vector<int>(4));

// 访问元素
matrix[1][2] = 10;

// 遍历
for (int i = 0; i < matrix.size(); i++) {
    for (int j = 0; j < matrix[i].size(); j++) {
        cout << matrix[i][j] << " ";
    }
    cout << endl;
}

// 范围for循环
for (auto& row : matrix) {
    for (auto& elem : row) {
        cout << elem << " ";
    }
    cout << endl;
}
```

### 6. vector的性能特性

#### 时间复杂度
- **随机访问**：O(1)
- **尾部插入/删除**：O(1) 平摊时间
- **中间插入/删除**：O(n)
- **查找**：O(n)

#### 内存管理
```cpp
vector<int> vec;
cout << "Capacity: " << vec.capacity() << endl; // 0

vec.push_back(1);
cout << "Capacity: " << vec.capacity() << endl; // 1

vec.push_back(2);
cout << "Capacity: " << vec.capacity() << endl; // 可能是2，也可能是更大的值

// vector通常会按倍数增长容量以减少重新分配次数
```