### C#异步编程入门概念及核心理念笔记

#### 一、异步编程与多线程的区别
1. **概念不同**
    - **异步**：不意味着多线程，单线程也可借助CPU时间片轮转调度实现异步，它更强调一种不阻塞当前线程完成任务的概念。
    - **多线程**：涉及创建多个线程来执行任务，线程间可能存在同步和先后顺序问题。
2. **特性差异**
    - **多线程**
        - 适合CPU密集型操作和长期运行的任务，能充分调动CPU核心进行计算。
        - 创建与销毁开销大，提供底层控制（如操作线程锁、信号量），但代码书写繁琐，不利于传参和返回结果。
        - 存在阻塞情况，会影响系统响应能力。
    - **异步**
        - 适合IO密集型操作，如频繁访问API、读取本地文件等短小频繁的任务，借助线程池，开销小。
        - 默认借助线程池，不阻塞当前线程，能提高系统响应能力，对底层同步原语操作不便，但代码简洁，可使用`async/await`灵活实现功能。
3. **适用场景**
    - **多线程**：长期运行的后台任务，如轮询任务。
    - **异步**：客户端UI线程操作（避免UI卡顿）、服务器后端开发（提高并发能力和响应速度）。

#### 二、异步任务（Task）
1. **Task**
    - 是包含异步任务各种状态的引用类型，有`status`等属性，可用于判断任务是否正在运行、完成、出错等。
    - 是实现异步编程的基本模块，借助它可实现多个异步任务共同完成任务。
    - 有普通`Task`（无返回值）和泛型`Task<T>`（有类型为`T`的返回值），都可用于获取任务状态和结果。
2. **ValueTask**
    - 值类型的版本，用法特殊，本文未详细讲解。

#### 三、async/await
1. **async**
    - 标记方法为异步方法，主要是为了能在方法体内使用`await`关键字，不改变函数本身的返回值。
    - 命名规范建议异步方法添加`async`后缀，方便调用者识别。
    - 在接口中无法使用`async`关键字，但实现接口时返回`Task`或使用`async`修饰返回`Task`的方法都可行。
2. **await**
    - 用于等待异步任务结束并获取结果，不会阻塞当前线程。
    - `async`和`await`将方法包装成状态机，`await`类似检查点，方法执行分阶段，通过状态切换实现。
    - 编译器会将`async`方法转换为包含状态机的底层代码，通过`MoveNext`方法实现状态切换。
3. **async void**
    - 也会被包装成状态机，但缺少`Task`返回值，无法使用`await`等待其完成和获取结果，异常处理困难，异常会直接抛出导致程序可能挂掉。
    - 仅在注册事件（如WPF中的`click`事件）且无法使用`async Task`时使用，需谨慎处理异常。
4. **传染性**
    - 一处`async`，处处`async`，调用异步方法时为避免阻塞和死锁，需将调用方法也改为`async`并在内部使用`await`，调用该方法的地方也可能需要改为`async`。
    - 但实际工作中不必过于担心，.NET原生提供了大量异步方法，即使遇到只有同步版本的第三方库，也可用`Task.Run`包装成异步方法。对于事件注册，可使用`async void`，但要注意异常处理。

#### 四、异步编程的重要思想和注意事项
1. **不阻塞**
    - 异步编程的核心是不阻塞当前线程，释放线程使其可执行其他操作，如避免在UI线程中使用同步方法导致界面卡顿，改用异步方法可解决此问题。
    - 不应在异步方法中使用阻塞方式（如`Thread.Sleep`、`Task.Result`等），应使用`Task.Delay`等不阻塞的异步任务，否则会使异步方法失去意义，可能导致线程池耗尽或死锁。
2. **同步上下文**
    - 是协调和管理线程的机制，借助它实现线程切换，如UI线程（WINFORM和WPF默认拥有）和线程池线程的切换。
    - `ConfigureAwait`可用于配置是否回到之前的同步上下文，默认值为`true`。在UI环境中，通常使用`ConfigureAwait(true)`确保回到UI线程进行操作；在不需要回到特定上下文时，可配置为`false`。
    - 错误配置`ConfigureAwait`可能导致死锁，如在使用`Task.Result`阻塞调用异步方法时，若`ConfigureAwait`为`true`，会因UI线程阻塞和异步任务等待回到UI线程的矛盾导致死锁，可将其配置为`false`解决。
3. **一发即忘**
    - 调用异步方法但不`await`或阻塞它，会忽略任务的返回值和状态，无法观察任务是否报错，本文未演示，后续可深入了解。

#### 五、创建和开启异步任务
1. **创建异步任务**
    - **Task.Run**：经典方式，将繁重任务包装成异步任务，避免阻塞，任务会在其他线程上运行。
    - **Task.Factory.StartNew**：`Task.Run`的完整版，提供更多功能，如设置任务创建选项、配置上下文和优先级等，有16个重载，而`Task.Run`有8个重载。
    - **new Task + Task.Start**：类似`new Thread + Thread.Start`，但一般不常用，多数情况下不考虑创建任务但不立刻开始使用。
2. **开启多个异步任务**
    - **错误方式**：在`for`循环中依次`await`每个异步任务，任务不会并行执行，速度慢。
    - **正确方式**
        - 使用`Task.WhenAll`：创建多个任务并添加到列表，然后`await Task.WhenAll`等待所有任务完成，可获取所有任务结果。
        - 使用`Task.WhenAny`：只要有任意一个任务完成就结束等待。

#### 六、异步任务的取消
使用`CancellationToken`，通过`CancellationTokenSource`创建`Token`，并将其传递给异步任务。在需要取消任务时，调用`CancellationTokenSource`的`Cancel`方法，异步任务会提前结束并抛出`TaskCanceledException`，需捕获该异常进行处理。同时，所有异步方法推荐带上`CancellationToken`参数。

#### 七、异步编程的常见误区
1. 异步不一定依靠多线程实现，单线程和多线程实现方式不同。
2. `async`关键字只是配合`await`使用，不改变函数返回值，接口中无法写`async Task`，但实现时可根据情况选择。
3. `await`不一定会切换同步上下文，若任务已完成则直接获取结果。
4. 异步编程不能全面取代多线程，二者有各自适用的场景。
5. `Task.Result`不一定会阻塞当前线程，若任务已完成则直接获取结果。
6. 开启异步任务后，任务不一定不阻塞当前线程，若在任务中编写阻塞代码仍可能阻塞。

#### 八、异步编程的同步机制
1. 传统多线程的同步机制（如锁等）不适用于异步编程，因为异步编程强调不阻塞，且无法在`lock`中使用`await`，编译器不允许，使用`Monitor`突破限制也不推荐。
2. 原生适合异步编程的同步机制只有`SemaphoreSlim`，可限制同时运行的任务数量，如限制爬虫访问频率、控制CPU开销等。
3. 还有一些第三方库（如`Microsoft.VisualStudio.Threading`、`Nito.AsyncEx`）提供适用于异步编程的额外同步机制，后续可专门了解。