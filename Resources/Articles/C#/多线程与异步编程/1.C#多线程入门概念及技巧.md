## **一、基本概念**  
### 1. 线程（Thread）  
- **定义**：操作系统中能独立运行的最小单位，是程序中能并发执行的指令序列。  
- **与进程的关系**：线程是进程的一部分，一个进程可包含多个线程，线程共享进程资源（如内存）。  
- **主线程**：程序入口函数所在的线程（如控制台程序的 `Main` 方法）。  


### 2. 为什么需要多线程？  
- **批量重复任务并发执行**：如处理数组元素（每个元素耗时操作），多线程可显著缩短总时间（例：10个耗时500ms的任务，单线程需5s，多线程仅需约500ms）。  
- **多任务互不干扰**：如主线程（UI线程）需保持响应，同时后台线程处理轮询（传感器）、IO操作（下载数据）等耗时任务，避免界面卡顿。  


### 3. 线程池（ThreadPool）  
- **定义**：预先创建的一组可重用线程，用于执行多个小任务，避免频繁创建/销毁线程的开销。  
- **特点**：现代异步编程（如 `async/await`）默认使用线程池，更高效且代码更简洁。  


### 4. 线程安全  
- **问题根源**：多个线程同时访问共享资源（如变量、队列），可能因操作非原子性导致数据不一致（如计数错误、队列元素重复输出）。  
- **示例**：  
  - 两个线程同时对共享变量 `count` 递增10万次，预期结果20万，实际因 `count++` 非原子操作（读-改-写分步执行）导致结果小于20万。  
  - 生产者-消费者模型中，普通队列因线程不安全导致元素重复输出或顺序混乱。  


---

## **二、线程安全的实现方式**  
### 1. 同步机制（协调线程执行顺序与互斥访问）  
- **互斥锁（Lock）**：通过 `lock(obj) { ... }` 确保同一时间只有一个线程访问共享资源。底层使用 `Monitor` 类（`lock` 是语法糖，编译为 `Monitor.Enter` 和 `Monitor.Exit`）。  
  - 示例：解决计数问题，加锁后结果正确为20万。  
- **其他同步工具**：  
  - `Mutex`：进程间共享的互斥锁（可用于限制程序多开）。  
  - `Semaphore`/`SemaphoreSlim`：信号量（控制并发线程数，如限制同时执行的任务数为3）。  
  - `ManualResetEvent`/`AutoResetEvent`：事件信号（一个线程通知另一个线程继续执行）。  
  - `ReaderWriterLockSlim`：读写锁（允许多个读线程或单个写线程，互斥读写）。  


### 2. 原子操作（不可分割的操作）  
- **定义**：执行过程中不会被中断的操作（如 `Interlocked.Increment`）。  
- **示例**：使用 `Interlocked.Increment(ref count)` 替代 `count++`，确保递增操作原子性，无需加锁即可得到正确结果20万。  


---

## **三、C# 多线程实现方式**  
### 1. 手动创建线程（`Thread` 类）  
- **创建与启动**：  
  ```csharp
  Thread thread = new Thread(Method); // Method 为线程执行的函数
  thread.Start(); // 启动线程
  ```  
- **配置参数**：  
  - 是否为后台线程（`IsBackground`）：后台线程随主线程退出而终止；前台线程需手动管理生命周期（如释放资源）。  
  - 优先级（`Priority`）：控制线程调度优先级（如 `Normal`、`High`）。  
- **传参**：通过 `ParameterizedThreadStart` 委托传递对象参数（需手动转换类型）。  


### 2. 线程终止  
- **`Join()`**：主线程阻塞等待子线程结束（例：主线程调用 `thread.Join()` 后，需等子线程完成后才继续执行）。  
- **`Interrupt()`**：中断线程（抛出 `ThreadInterruptedException`，需在 `try-catch` 中捕获并处理）。注意：线程需有阻塞操作（如 `Thread.Sleep`、`Wait`）才能响应中断；无限循环需添加 `Sleep(0)` 或 `Sleep(1)` 让出CPU。  
- **避免使用 `Abort()`**：已过时且不安全（可能导致资源未释放、状态不一致）。  


### 3. 自带高效方法（避免手动管理线程）  
- **`Parallel` 类**：简化并行循环，如 `Parallel.For`（并行执行循环）、`Parallel.ForEach`（并行遍历集合）、`Parallel.Invoke`（并行执行多个方法）。  
  - 示例：`Parallel.For(0, input.Length, i => output[i] = HeavyJob(input[i]))` 可大幅缩短耗时（20个耗时100ms的任务，单线程需2000ms，并行仅需约200ms）。  
- **PLINQ（并行LINQ）**：通过 `AsParallel()` 将 LINQ 查询转为并行执行（如 `input.AsParallel().Select(x => x * x)`），支持 `AsOrdered()` 保证顺序。  


---

## **四、不要造轮子（使用内置线程安全工具）**  
- **线程安全集合**：以 `Concurrent` 命名空间下的类型（如 `ConcurrentQueue`、`ConcurrentStack`、`ConcurrentDictionary`），无需手动加锁即可安全使用。  
  - 示例：生产者-消费者模型中，使用 `ConcurrentQueue` 替代普通队列，避免元素重复输出。  
- **阻塞集合（`BlockingCollection`）**：专为生产者-消费者设计，自动处理线程同步与阻塞（无需手动信号量）。  
- **原子操作类（`Interlocked`）**：提供 `Increment`、`Decrement`、`Exchange` 等方法，高效实现原子操作。  


---

## **五、阻塞与轮询**  
- **轮询**：定期检查共享资源（如每隔50ms检查队列是否有数据），CPU占用高且可能有延迟。  
- **阻塞（信号量）**：线程等待信号（如 `Semaphore.WaitOne()`），底层挂起线程，CPU占用低且无延迟（信号到达时唤醒）。推荐使用阻塞机制替代轮询。  


---

## **总结**  
- **核心目标**：通过多线程实现任务并发，提升程序效率（批量任务）或响应性（UI不卡顿）。  
- **关键概念**：线程安全（同步机制、原子操作）、线程池、避免手动造轮子（使用 `Parallel`、线程安全集合等）。  
- **最佳实践**：优先使用 `async/await`（基于线程池）、`Parallel`、线程安全集合，减少手动线程管理；谨慎处理线程终止与资源共享。