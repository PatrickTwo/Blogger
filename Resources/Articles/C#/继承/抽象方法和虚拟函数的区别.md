### My Note
> 抽象方法必须包含在抽象类中

---

在C#中，**抽象方法（Abstract Method）**和**虚拟函数（Virtual Function）**都是面向对象编程中用于实现多态性的重要机制，但它们在使用场景和行为上有一些关键区别。以下是它们的详细对比：

---

### 1. **定义与关键字**
- **抽象方法**：
  - 使用 `abstract` 关键字定义。
  - 只能在抽象类（`abstract class`）中声明。
  - 没有方法体（即没有实现），必须在派生类中重写。
  - 示例：
    ```csharp
    abstract class Animal
    {
        public abstract void MakeSound(); // 抽象方法，没有实现
    }
    ```

- **虚拟函数**：
  - 使用 `virtual` 关键字定义。
  - 可以在普通类或抽象类中声明。
  - 必须有方法体（即提供默认实现），但可以在派生类中重写。
  - 示例：
    ```csharp
    class Animal
    {
        public virtual void MakeSound() // 虚拟函数，有默认实现
        {
            Console.WriteLine("Animal sound...");
        }
    }
    ```

---

### 2. **是否必须重写**
- **抽象方法**：
  - **必须**在派生类中重写（除非派生类也是抽象类）。
  - 如果派生类不是抽象类，则必须使用 `override` 关键字实现抽象方法。
  - 示例：
    ```csharp
    class Dog : Animal
    {
        public override void MakeSound() // 必须重写
        {
            Console.WriteLine("Barking...");
        }
    }
    ```

- **虚拟函数**：
  - **可以**在派生类中重写，但不是必须的。
  - 如果派生类不重写，则使用基类中的默认实现。
  - 示例：
    ```csharp
    class Dog : Animal
    {
        // 可以不重写 MakeSound，直接使用基类的实现
    }
    ```

---

### 3. **类的实例化**
- **抽象方法**：
  - 包含抽象方法的类必须是抽象类（`abstract class`），**不能直接实例化**。
  - 示例：
    ```csharp
    abstract class Animal
    {
        public abstract void MakeSound();
    }

    // Animal animal = new Animal(); // 错误：不能实例化抽象类
    ```

- **虚拟函数**：
  - 包含虚拟函数的类可以是普通类或抽象类，**可以直接实例化**。
  - 示例：
    ```csharp
    class Animal
    {
        public virtual void MakeSound()
        {
            Console.WriteLine("Animal sound...");
        }
    }

    Animal animal = new Animal(); // 可以实例化
    animal.MakeSound(); // 输出：Animal sound...
    ```

---

### 4. **设计意图**
- **抽象方法**：
  - 用于强制派生类实现特定的行为。
  - 适用于定义一种“契约”，要求所有派生类必须提供具体的实现。
  - 示例：
    ```csharp
    abstract class Shape
    {
        public abstract double GetArea(); // 所有形状必须实现计算面积的方法
    }
    ```

- **虚拟函数**：
  - 用于提供一种默认行为，同时允许派生类根据需要重写。
  - 适用于需要扩展或修改基类行为的场景。
  - 示例：
    ```csharp
    class Vehicle
    {
        public virtual void Start()
        {
            Console.WriteLine("Vehicle started...");
        }
    }

    class Car : Vehicle
    {
        public override void Start()
        {
            Console.WriteLine("Car started...");
        }
    }
    ```

---

### 5. **性能**
- **抽象方法**：
  - 由于必须在派生类中实现，调用时直接指向派生类的实现，性能较高。
- **虚拟函数**：
  - 由于可能被重写，调用时需要通过虚表（vtable）查找具体实现，性能稍低（但差异通常可以忽略）。

---

### 6. **总结对比**

| 特性                | 抽象方法 (`abstract`)                     | 虚拟函数 (`virtual`)                     |
|---------------------|------------------------------------------|------------------------------------------|
| **关键字**           | `abstract`                              | `virtual`                               |
| **方法体**           | 无（必须在派生类中实现）                 | 有（可以在派生类中重写）                 |
| **是否必须重写**     | 必须重写（除非派生类是抽象类）           | 可选重写                               |
| **类的实例化**       | 只能在抽象类中声明，不能实例化           | 可以在普通类中声明，可以实例化           |
| **设计意图**         | 强制派生类实现特定行为                   | 提供默认行为，允许派生类扩展或修改       |
| **性能**             | 较高（直接调用派生类实现）               | 稍低（通过虚表查找实现）                 |

---

### 7. **使用场景**
- **抽象方法**：
  - 当需要强制派生类实现某些行为时（例如，定义接口或基类契约）。
  - 示例：计算形状的面积、动物的叫声等。
- **虚拟函数**：
  - 当需要提供默认行为，同时允许派生类根据需要重写时。
  - 示例：车辆的启动方式、动物的移动方式等。

---

### 8. **代码示例对比**
```csharp
// 抽象方法示例
abstract class Animal
{
    public abstract void MakeSound(); // 必须实现
}

class Dog : Animal
{
    public override void MakeSound() // 必须重写
    {
        Console.WriteLine("Barking...");
    }
}

// 虚拟函数示例
class Vehicle
{
    public virtual void Start() // 提供默认实现
    {
        Console.WriteLine("Vehicle started...");
    }
}

class Car : Vehicle
{
    public override void Start() // 可选重写
    {
        Console.WriteLine("Car started...");
    }
}
```

---

### 总结
- **抽象方法**用于强制派生类实现特定行为，适用于定义契约。
- **虚拟函数**用于提供默认行为，同时允许派生类扩展或修改。
- 根据具体需求选择使用抽象方法或虚拟函数，可以更好地实现多态性和代码复用。