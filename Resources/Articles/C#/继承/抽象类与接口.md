# **抽象类（Abstract Class）与接口（Interface）详解**

在面向对象编程（OOP）中，**抽象类**和**接口**都是用于实现**多态性**和**代码复用**的重要机制，但它们的设计目的和使用方式有所不同。下面详细讲解它们的区别、适用场景及示例代码。

---

## **1. 抽象类（Abstract Class）**
### **定义**
- 抽象类是用 `abstract` 关键字声明的类，**不能被实例化**（即不能 `new AbstractClass()`）。
- 它可以包含**普通方法（有实现）**和**抽象方法（无实现）**。
- 子类必须实现所有抽象方法（除非子类也是抽象类）。

### **特点**
✅ **可以包含具体方法**（有方法体）。  
✅ **可以包含字段（成员变量）、属性、构造函数**。  
✅ **支持访问修饰符（`public`/`protected`/`private`）**。  
✅ **子类只能继承一个抽象类（单继承）**。  

### **适用场景**
- 多个类有**共同的逻辑**，但部分行为需要子类自定义。
- 需要**共享代码**（如基类提供默认实现）。
- 适用于**"IS-A"关系**（如 `Dog` **is a** `Animal`）。

### **示例**
```csharp
// 抽象类
public abstract class Animal
{
    // 普通方法（有实现）
    public void Eat()
    {
        Console.WriteLine("Animal is eating.");
    }

    // 抽象方法（无实现，子类必须实现）
    public abstract void MakeSound();
}

// 子类
public class Dog : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Bark!");
    }
}

// 使用
Animal myDog = new Dog();
myDog.Eat();       // 输出: Animal is eating.
myDog.MakeSound(); // 输出: Bark!
```

---

## **2. 接口（Interface）**
### **定义**
- 接口是用 `interface` 关键字声明的**纯抽象契约**，**不能包含任何实现**（C# 8.0+ 支持默认实现，但不推荐滥用）。
- 它只定义**方法签名、属性、事件或索引器**，不包含字段。
- 类可以**实现多个接口**（多继承）。

### **特点**
✅ **只能包含抽象成员**（默认 `public`，不能加访问修饰符）。  
✅ **不能包含字段、构造函数**（但可以包含属性）。  
✅ **类可以实现多个接口**（解决单继承限制）。  
✅ **适用于"CAN-DO"关系**（如 `Bird` **can** `IFly`）。  

### **适用场景**
- 定义**行为契约**（如 `ISaveable`、`IDrawable`）。
- 需要**多继承**（一个类实现多个接口）。
- 适用于**跨不同继承树的类**（如 `Plane` 和 `Bird` 都能 `IFly`）。

### **示例**
```csharp
// 接口
public interface IFly
{
    void Fly(); // 默认 public，不能加实现
}

public interface ISwim
{
    void Swim();
}

// 类实现多个接口
public class Duck : IFly, ISwim
{
    public void Fly()
    {
        Console.WriteLine("Duck is flying.");
    }

    public void Swim()
    {
        Console.WriteLine("Duck is swimming.");
    }
}

// 使用
Duck duck = new Duck();
duck.Fly();  // 输出: Duck is flying.
duck.Swim(); // 输出: Duck is swimming.
```

---

## **3. 抽象类 vs 接口**
| **特性**                | **抽象类（Abstract Class）**       | **接口（Interface）**              |
|-------------------------|-----------------------------------|-----------------------------------|
| **关键字**              | `abstract class`                 | `interface`                       |
| **实例化**              | ❌ 不能                          | ❌ 不能                          |
| **默认方法实现**        | ✅ 可以                          | ❌ 不能（C# 8.0+ 支持但不推荐）   |
| **字段/属性**           | ✅ 可以                          | ❌ 不能（但可以有属性）           |
| **构造函数**            | ✅ 可以                          | ❌ 不能                          |
| **继承方式**            | 单继承（一个子类只能继承一个）    | 多继承（一个类可以实现多个接口）  |
| **访问修饰符**          | 支持 `public`/`protected`/`private` | 默认 `public`，不能加修饰符       |
| **适用关系**            | **IS-A**（如 `Dog` is an `Animal`） | **CAN-DO**（如 `Bird` can `IFly`） |

---

## **4. 如何选择？**
### **使用抽象类的情况**
- 多个类有**共享的逻辑**（如公共方法）。
- 需要**基类控制部分行为**，子类只扩展特定部分。
- 适用于**紧密耦合的类层次结构**（如游戏中的 `Enemy` 基类）。

### **使用接口的情况**
- 需要**定义行为契约**（如 `IComparable`、`IDisposable`）。
- 类需要**实现多个不相关的功能**（如 `Bird` 能 `IFly` 和 `ISing`）。
- 适用于**松散耦合的系统**（如插件架构）。

---

## **5. 综合示例**
```csharp
// 抽象类（共享逻辑）
public abstract class Vehicle
{
    public string Model { get; set; }

    public void StartEngine()
    {
        Console.WriteLine("Engine started.");
    }

    public abstract void Move();
}

// 接口（定义额外能力）
public interface IRadio
{
    void PlayMusic();
}

// 子类继承抽象类并实现接口
public class Car : Vehicle, IRadio
{
    public override void Move()
    {
        Console.WriteLine("Car is driving.");
    }

    public void PlayMusic()
    {
        Console.WriteLine("Playing music...");
    }
}

// 使用
Car myCar = new Car();
myCar.StartEngine(); // 继承自 Vehicle
myCar.Move();        // 实现抽象方法
myCar.PlayMusic();   // 实现接口方法
```

---

## **6. 总结**
- **抽象类**：用于**代码复用**和**定义部分实现**，适合 `IS-A` 关系。
- **接口**：用于**定义行为契约**，适合 `CAN-DO` 关系，支持多继承。
- **优先使用接口**，除非需要共享代码才用抽象类。

理解它们的区别后，可以更灵活地设计面向对象的系统！ 🚀