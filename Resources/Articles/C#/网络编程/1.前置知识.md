# 前置知识

## IP地址与端口类

- IP地址类（`IPAddress`）
- 端口类（`IPEndPoint`）
 
#### **核心知识点**  

##### **1. IP类和端口类的作用**  
网络通信的前提是定位目标设备，**IP地址**（标识设备）和**端口号**（标识设备上运行的程序）是关键元素。C#提供`IPAddress`（IP地址类）和`IPEndPoint`（IP+端口组合类）用于声明这些信息，后续网络通信需依赖此类对象。  


##### **2. IPAddress类（IP地址类）**  
- **命名空间**：`System.Net`。  
- **作用**：表示IP地址（IPv4/IPv6），用于初始化和存储IP地址信息。  

- **初始化方式**（重点掌握第3种）：  
  - **① 字节数组初始化**（不推荐）：  
    声明4字节数组（IPv4规则），通过`new IPAddress(byte[])`构造。  
    ```csharp
    byte[] ipBytes = { 118, 102, 111, 11 }; // 示例：对应IP "118.102.111.11"
    IPAddress ip1 = new IPAddress(ipBytes); 
    ```  
  - **② 长整型初始化**（不推荐）：  
    需将IP地址转换为32位长整型（如十六进制），通过`new IPAddress(long)`构造。转换复杂（需借助计算器工具），实际极少使用。  
    ```csharp
    // 示例：IP "118.102.111.11" 转十六进制为0x79666F0B，对应长整型
    long ipLong = 0x79666F0B; 
    IPAddress ip2 = new IPAddress(ipLong); 
    ```  
  - **③ 字符串解析（推荐）**：  
    使用`IPAddress.Parse(string)`静态方法，直接将IPv4字符串（如"192.168.1.1"）转换为`IPAddress`对象，最便捷。  
    ```csharp
    IPAddress ip3 = IPAddress.Parse("118.102.111.11"); // 推荐方式
    ```  

- **特殊IP地址**：  
  - `127.0.0.1`：本地回环地址，代表本机，无需查询本机实际IP即可使用。  
  - IPv6相关：`IPAddress.IPv6Any`（静态成员）可返回本机可用的IPv6地址（若需IPv6通信时使用）。  


##### **3. IPEndPoint类（IP+端口组合类）**  
- **命名空间**：`System.Net`。  
- **作用**：表示网络通信的端点（IP地址+端口号的组合），用于定位远程设备的特定程序（如服务器进程）。  

- **初始化方式**（重点掌握第2种）：  
  - **① 长整型+端口（不推荐）**：  
    第一个参数为IP地址的长整型（同`IPAddress`的长整型初始化），第二个为端口号（int）。因IP长整型转换复杂，极少使用。  
    ```csharp
    IPEndPoint point1 = new IPEndPoint(ipLong, 8080); // 端口8080
    ```  
  - **② IPAddress对象+端口（推荐）**：  
    第一个参数为`IPAddress`对象（可直接通过`IPAddress.Parse`快速生成），第二个为端口号（int）。最常用，直观易操作。  
    ```csharp
    IPAddress ip = IPAddress.Parse("118.102.111.11"); 
    IPEndPoint point2 = new IPEndPoint(ip, 8080); // 推荐方式：IP+端口组合
    ```  


#### **四、总结**  
- **IP地址表示**：用`IPAddress`类，通过`IPAddress.Parse("IPv4字符串")`快速创建对象。  
- **通信目标表示**：用`IPEndPoint`类，通过`new IPEndPoint(IPAddress对象, 端口号)`创建，包含IP和端口信息，后续网络通信需传递此对象定位目标程序。  


**关键提示**：IP和端口是网络通信的基础，需先掌握`IPAddress`和`IPEndPoint`的初始化，才能进行后续连接与数据传输。

## 域名解析
- **作用**：将域名（如"www.baidu.com"）转换为对应的IP地址，使计算机能够识别和定位目标服务器。  
- **DNS服务器**：域名解析由DNS服务器负责，负责将域名转换为IP地址。  

#### **核心知识点**  
##### ** IPHostEntry类（域名解析类）**
- **命名空间**：`System.Net`。  
- **作用**：表示域名解析结果，可以通过该对象获取IP地址、主机名等等信息。
- **常用字段**：
  - `AddressList`：IP地址列表，包含域名解析出的所有IP地址（IPv4/IPv6）。  
  - `HostName`：主机名，解析出的域名（如"www.baidu.com"）。  
  - `Aliases`：别名列表，解析出的其他主机名（如"www.baidu.com"的"www"）。  
##### ** DNS类 **
- **命名空间**：`System.Net`。  
- **作用**：静态类，提供域名解析功能。  
- **常用方法**：
  - `GetHostName()`：获取当前计算机的主机名。  
  - `GetHostEntry(string)`：同步方法，将域名解析为`IPHostEntry`对象，包含IP地址列表、主机名、别名等信息。  
  - `GetHostEntryAsync(string)`：异步方法，将域名解析为`IPHostEntry`对象，返回`Task<IPHostEntry>`。  

## 序列化与反序列化
- **序列化**： 将对象转换为字节序列，用于存储或传输。  
- **反序列化**： 将字节序列转换为对象，用于恢复原始对象状态。   

#### **核心知识点**
数据持久化2进制知识点

和网络通信相关的重要知识点（会在网络通信中频繁使用）：

1. BitConverter类：主要用于处理各类型和字节数组间的相互转换
2. Encoding类：主要用于处理字符串类型和字节数组间的相互转换
3. 加密相关：了解2进制数据加密的常用手段和思路

本地持久化知识点：

1. File类：文件操作类，用于操作文件
2. FileStream类：文件流类，以流的形式进行文件存储读取操作
3. MemoryStrem：内存流对象
4. BinaryFormatter：2进制格式化对象
> 网络编程中一般不使用BinaryFormatter，由于客户端与服务端的编程语言差异，该类序列化的语言无法兼容其他语言，常用BitConverter和Encoding类进行2进制和字符串的转换。
### 序列化
##### **1. 非字符串类型转字节数组（BitConverter类）**  
- **命名空间**：`System`。  
- **作用**：将除字符串外的常用类型（如 `int`、`bool`、`float`、`short` 等）转换为字节数组。  
- **用法**：通过 `BitConverter.GetBytes(值)` 方法，直接传入对应类型的值，返回字节数组。  
  ```csharp
  int num = 1;
  byte[] intBytes = BitConverter.GetBytes(num); // int转字节数组（4字节）
  
  bool flag = true;
  byte[] boolBytes = BitConverter.GetBytes(flag); // bool转字节数组（1字节）
  ```  

##### **2. 字符串类型转字节数组（Encoding类）**  
- **命名空间**：`System.Text`。  
- **作用**：将字符串转换为字节数组，需指定编码格式（网络通信推荐 `UTF-8`）。  
- **用法**：通过 `Encoding.UTF8.GetBytes(字符串)` 方法，返回 UTF-8 编码的字节数组。  
  ```csharp
  string str = "123";
  byte[] strBytes = Encoding.UTF8.GetBytes(str); // 字符串转UTF-8字节数组（长度可变）
  ```  


#### **3. 类对象转二进制数据**  
> 网络编程中一般不使用BinaryFormatter，由于客户端与服务端的编程语言差异，该类序列化的语言无法兼容其他语言
##### **1. 序列化步骤**  
需完成三步：**明确字节数组容量 → 声明字节数组容器 → 将对象信息转为字节数组并存入容器**。  

##### **2. 示例：PlayerInfo类序列化**  
以自定义类 `PlayerInfo`为例，演示序列化过程。  
``` C#
public class PlayerInfo
{
    public int level;
    public string name;
    public short atk;
    public bool sex;
}
```
###### **步骤1：明确字节数组容量**  
需计算类对象中所有字段转换为字节数组后的总长度，关键是**字符串需额外存储长度**（因字符串字节数可变，解析时需知道长度才能准确截取）。  
- `level`（int）：4字节（固定）。  
- `name`（string）：需先存长度（int，4字节）+ 字符串字节数组长度（如“唐老师”转UTF-8后为6字节）。  
- `atk`（short）：2字节（固定）。  
- `sex`（bool）：1字节（固定）。  
- **总长度** = 4（level） + 4（name长度） + 6（name字节数组） + 2（atk） + 1（sex）= 17字节（示例值）。  

###### **步骤2：声明字节数组容器**  
根据总长度声明字节数组：  
```csharp
int totalLength = 17; // 实际需动态计算（见下文）
byte[] playerBytes = new byte[totalLength];
```  

###### **步骤3：将对象信息转为字节数组并存入容器**  
使用 `Array.CopyTo()` 方法将各字段的字节数组拷贝到总容器中，需注意**字符串先存长度再存内容**。  

**示例代码（手动实现）**：  
```csharp
PlayerInfo info = new PlayerInfo {
    level = 10,
    name = "123",
    atk = 88,
    sex = false
};

// 步骤1：计算总长度（动态）
int index = 0; // 记录当前写入位置
// level（int，4字节）
index += sizeof(int); 
// name：先存长度（int，4字节）+ 字符串字节数组长度（动态）
byte[] nameBytes = Encoding.UTF8.GetBytes(info.name);
index += sizeof(int) + nameBytes.Length; 
// atk（short，2字节）
index += sizeof(short); 
// sex（bool，1字节）
index += sizeof(bool); 
int totalLength = index; // 总长度确定
byte[] playerBytes = new byte[totalLength];

// 步骤2：拷贝各字段到容器
index = 0; // 重置写入位置
// 拷贝level
byte[] levelBytes = BitConverter.GetBytes(info.level);
levelBytes.CopyTo(playerBytes, index);
index += sizeof(int); 

// 拷贝name长度+内容
byte[] nameLengthBytes = BitConverter.GetBytes(nameBytes.Length);
nameLengthBytes.CopyTo(playerBytes, index); // 先存长度（4字节）
index += sizeof(int); 
nameBytes.CopyTo(playerBytes, index); // 再存字符串字节数组
index += nameBytes.Length; 

// 拷贝atk
byte[] atkBytes = BitConverter.GetBytes(info.atk);
atkBytes.CopyTo(playerBytes, index);
index += sizeof(short); 

// 拷贝sex
byte[] sexBytes = BitConverter.GetBytes(info.sex);
sexBytes.CopyTo(playerBytes, index);
```  


##### **3. 封装序列化方法（优化）**  
可将序列化逻辑封装到类内部，作为成员方法（如 `GetBytes()`），提高复用性：  
```csharp
public class PlayerInfo {
    public int level;
    public string name;
    public short atk;
    public bool sex;

    public byte[] GetBytes() {
        // 动态计算总长度（同步骤1）
        int index = 0;
        byte[] nameBytes = Encoding.UTF8.GetBytes(name);
        int totalLength = sizeof(int) + sizeof(int) + nameBytes.Length + sizeof(short) + sizeof(bool);
        byte[] playerBytes = new byte[totalLength];

        // 拷贝各字段（同步骤3）
        index = 0;
        BitConverter.GetBytes(level).CopyTo(playerBytes, index);
        index += sizeof(int);
        BitConverter.GetBytes(nameBytes.Length).CopyTo(playerBytes, index);
        index += sizeof(int);
        nameBytes.CopyTo(playerBytes, index);
        index += nameBytes.Length;
        BitConverter.GetBytes(atk).CopyTo(playerBytes, index);
        index += sizeof(short);
        BitConverter.GetBytes(sex).CopyTo(playerBytes, index);

        return playerBytes;
    }
}
```  


#### **四、关键注意事项**  
1. **字符串存储规则**：必须先存长度（int类型，4字节），再存字符串字节数组。否则反序列化时无法确定字符串的截取范围。  
2. **字节数组容量计算**：需动态计算（尤其字符串长度可变），避免硬编码。可通过 `sizeof(类型)` 获取固定类型长度（如 `sizeof(int)=4`）。  
3. **兼容性**：避免使用 `BinaryFormatter`（C#专用，跨语言兼容性差），需手动序列化以保证与其他语言（如Java、Python）交互。  


### 反序列化
1. 字节数组转非字符串类型
2. 字节数组转字符串类型
3. 二进制数据转类对象

#### 1. 字节数组转非字符串类型
类： `BitConverter`
```C#
int num = 100;
byte[]bytes = BitConverter.GetBytes(num);
int num2 = BitConverter.ToInt32(bytes, 0);
```

#### 2. 字节数组转字符串类型
类： `Encoding`
将字符串类型和字节数组相互转换，并决定使用何种编码
```C#
string str = "123";
byte[]bytes = Encoding.UTF8.GetBytes(str);
string str2 = Encoding.UTF8.GetString(bytes);
```

#### 3. 二进制数据转类对象
步骤：
1. 获取到对应的字节数组
2. 将字节数组按照序列化时的顺序进行反序列化（将对应字节分组转换为对应类型变量）
```C#
byte[] playerBytes = info.GetBytes(); // 获取类对象字节数组
// 用于接受反序列化结果的类对象
playerInfo _info = new playerInfo();
int index = 0;
// 按照序列化的顺序解析
// 等级
_info.level = BitConverter.ToInt32(playerBytes, index);
index += sizeof(int);
// 姓名长度
int nameLength = BitConverter.ToInt32(playerBytes, index);
index += sizeof(int);
// 姓名
_info.name = Encoding.UTF8.GetString(playerBytes, index, nameLength);
index += nameLength;
// 攻击力
_info.atk = BitConverter.ToInt16(playerBytes, index);
index += sizeof(short);
// 性别
_info.sex = BitConverter.ToBoolean(playerBytes, index);
index += sizeof(bool);
```