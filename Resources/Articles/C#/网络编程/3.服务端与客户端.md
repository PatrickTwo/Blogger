## TCP通信同步方案·服务端实现

---

### **一、开发环境与项目准备**  
- **环境选择**：服务端使用**控制台程序**即可，无需Unity。  
- **项目创建**：新建控制台应用（如命名为`TeachTCPServer`），框架选`.NET Core 3.1`（避免VS2022顶级语法省略，建议手动补全代码）。  
- **基础代码**：初始打印“按任意键退出”并阻塞（`Console.ReadKey()`），防止程序自动关闭。  

---

### **二、服务端核心流程**  
服务端需完成以下步骤：  
1. **创建套接字**：实例化TCP Socket对象。  
2. **绑定地址**：将Socket与本机IP和端口绑定（`Bind`方法）。  
3. **监听连接**：设置最大客户端连接数（`Listen`方法）。  
4. **接受连接**：阻塞等待客户端连接（`Accept`方法，返回新Socket用于通信）。  
5. **收发数据**：通过新Socket的`Send`（发送）和`Receive`（接收）方法与客户端交互。  
6. **关闭连接**：调用`Shutdown`释放连接，再调用`Close`彻底关闭Socket。  

---

### **三、服务端代码实现（分步详解）**  

#### **1. 创建TCP套接字**  
```csharp
// 声明TCP套接字（IPv4寻址、流类型、TCP协议）
Socket socketTcp = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
```  

#### **2. 绑定本地地址（IP+端口）**  
- **IPEndPoint对象**：指定本机IP（如`127.0.0.1`）和端口（>1024且未被占用，如`8080`）。  
- **异常处理**：绑定可能因IP/端口非法或占用失败，需用`try-catch`捕获错误。  
```csharp
IPEndPoint ipEndPoint = new IPEndPoint(IPAddress.Parse("127.0.0.1"), 8080);
try {
    socketTcp.Bind(ipEndPoint); // 绑定IP和端口
} catch (Exception ex) {
    Console.WriteLine($"绑定报错：{ex.Message}");
    return; // 绑定失败则终止后续逻辑
}
```  

#### **3. 监听客户端连接**  
- **Listen方法**：设置最大连接数（如`1024`，根据实际需求调整）。  
- **提示信息**：绑定和监听成功后打印状态。  
```csharp
socketTcp.Listen(1024); // 最大允许1024个客户端连接
Console.WriteLine("服务端绑定监听结束，等待客户端连入...");
```  

#### **4. 接受客户端连接（阻塞式）**  
- **Accept方法**：阻塞主线程，直到有客户端连接；返回新Socket（`socketClient`）用于与该客户端通信。  
- **验证阻塞特性**：通过断点或逐行调试观察，执行到`Accept`时会暂停，直到客户端连接后才继续。  
```csharp
Socket socketClient = socketTcp.Accept(); // 阻塞等待客户端连接
Console.WriteLine("有客户端连入！"); // 此句需客户端连接后才会执行
```  

#### **5. 收发数据（同步方法）**  
- **发送数据**：`Send`方法需将字符串转为UTF-8字节数组（网络通信推荐编码）。  
  ```csharp
  string welcomeMsg = "欢迎连入啊服务端";
  byte[] sendData = System.Text.Encoding.UTF8.GetBytes(welcomeMsg);
  socketClient.Send(sendData); // 发送欢迎消息
  ```  
- **接收数据**：`Receive`方法需预先声明字节数组作为缓存，返回值为实际接收的字节数（关键！用于解析有效数据）。  
  ```csharp
  byte[] receiveBuffer = new byte[1024]; // 1KB缓存
  int receiveLength = socketClient.Receive(receiveBuffer); // 接收数据，返回字节数
  // 解析接收的字符串（从0开始，长度为receiveLength）
  string receivedMsg = Encoding.UTF8.GetString(receiveBuffer, 0, receiveLength);
  // 打印客户端IP和消息
  Console.WriteLine($"接收到客户端[{socketClient.RemoteEndPoint}]的消息：{receivedMsg}");
  ```  

#### **6. 关闭连接**  
- **Shutdown**：停止收发（`SocketShutdown.Both`表示同时停止发送和接收）。  
- **Close**：释放Socket资源，彻底关闭连接（注意：关闭的是与客户端通信的`socketClient`，而非服务端的`socketTcp`）。  
```csharp
socketClient.Shutdown(SocketShutdown.Both); // 停止收发
socketClient.Close(); // 关闭连接
```  

---

### **四、关键注意事项**  
1. **同步方法的阻塞性**：`Accept`、`Receive`均为阻塞式方法，会暂停主线程直到操作完成（如等待连接或数据）。  
2. **接收数据的解析**：`Receive`的返回值是实际接收的字节数，需用此值截取有效数据（避免解析无效缓存）。  
3. **多客户端支持**：当前代码仅能处理单个客户端连接，后续需通过多线程/异步解决多客户端并发问题（本节课未涉及）。  

---


## TCP通信同步方案·客户端实现

---

### **一、客户端核心流程**  
客户端需完成以下步骤（本节课重点实现）：  
1. **创建套接字**：实例化TCP Socket对象（与服务端类型一致）。  
2. **连接服务端**：通过`Connect`方法连接服务端（需服务端IP和端口）。  
3. **收发数据**：使用`Send`（发送）和`Receive`（接收）方法与服务端交互。  
4. **关闭连接**：调用`Shutdown`释放连接，再调用`Close`彻底关闭Socket。  

---

### **二、客户端代码实现（分步详解）**  

#### **1. 创建TCP套接字**  
与服务端一致，使用IPv4寻址、流类型、TCP协议：  
```csharp
// 声明TCP套接字（IPv4寻址、流类型、TCP协议）
Socket socketClient = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
```  

#### **2. 连接服务端（关键步骤）**  
- **IPEndPoint对象**：指定服务端IP（本机开发时为`127.0.0.1`，远端服务器为实际IP）和端口（如`8080`）。  
- **异常处理**：连接失败可能因服务端未启动或拒绝连接（错误码`10061`表示服务器拒绝），需用`try-catch`捕获`SocketException`。  
```csharp
IPEndPoint serverEndPoint = new IPEndPoint(IPAddress.Parse("127.0.0.1"), 8080); // 服务端IP和端口
try {
    socketClient.Connect(serverEndPoint); // 连接服务端
} 
catch (SocketException ex) {
    Console.WriteLine($"连接服务器失败，错误码：{ex.ErrorCode}");
    return; // 连接失败则终止后续逻辑
}
```  

#### **3. 接收服务端数据**  
- **Receive方法**：需预先声明字节数组作为缓存，返回值为实际接收的字节数（关键！用于解析有效数据）。  
- **编码转换**：网络通信推荐使用UTF-8编码，将字节数组转为字符串。  
```csharp
byte[] receiveBuffer = new byte[1024]; // 1KB缓存
int receiveLength = socketClient.Receive(receiveBuffer); // 接收数据，返回字节数
string receivedMsg = UTF8.GetString(receiveBuffer, 0, receiveLength);
Console.WriteLine($"收到服务端消息：{receivedMsg}");
```  

#### **4. 发送数据到服务端**  
- **Send方法**：将字符串转为UTF-8字节数组后发送。  
```csharp
string sendMsg = "这是客户端";
byte[] sendData = Encoding.UTF8.GetBytes(sendMsg);
socketClient.Send(sendData); // 发送消息
```  

#### **5. 关闭连接**  
与服务端一致，先停止收发再关闭：  
```csharp
socketClient.Shutdown(SocketShutdown.Both); // 停止收发
socketClient.Close(); // 关闭连接
```  

---


### **三、关键注意事项**  
1. **连接IP的区别**：客户端`Connect`的IP是**服务端IP**（本机开发时为`127.0.0.1`，非客户端自身IP）。  
2. **同步方法的阻塞性**：`Connect`、`Receive`、`Send`均为阻塞式方法，会暂停主线程直到操作完成（如等待连接或数据）。  
3. **客户端与服务端的Socket差异**：  
   - 服务端：`Accept`返回新Socket用于与客户端通信（原Socket继续监听）。  
   - 客户端：始终使用自身创建的Socket（`socketClient`）与服务端通信。  

---

## **服务端示例**

:::info
功能实现：  
1. 允许多个客户端连入服务器；  
2. 可分别与多个客户端通信（收发消息）。  
:::

实现步骤
- 建立Socket、绑定、监听
- 等待连接
- 收发消息
- 关闭资源

### **1. Socket初始化**  
声明静态Socket（供多线程访问）：
`static Socket serverSocket;`  
```csharp
// 创建Socket
serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
// 绑定IP和端口
serverSocket.Bind(new IPEndPoint(IPAddress.Parse("127.0.0.1"), 8080));
// 监听连接（1024为最大挂起连接数，实际通过逻辑控制连接数）  
serverSocket.Listen(1024);
```

### **2. 多线程处理客户端连接（允许多客户端接入）**  
**问题**：单线程`Accept()`是阻塞函数，会阻塞代码执行。  
**解决**：单独开线程循环调用`Accept()`，持续监听新连接，将客户端Socket存入列表。  

**实现**：  
- **客户端Socket列表**：
`static List<Socket> clientSockets = new List<Socket>();`（存储所有连接的客户端Socket）。  
- **创建“接受连接”线程**：  
  ```csharp
  Thread acceptThread = new Thread(AcceptClientConnect); // AcceptClientConnect为处理连接的方法  
  acceptThread.Start();  
  ```  
- **线程方法逻辑（死循环监听连接）**：  
  ```csharp
  static void AcceptClientConnect() {  
      while (!isClose) { // isClose为控制线程退出的标志（布尔值，默认false）  
          Socket clientSocket = serverSocket.Accept(); // 阻塞等待客户端连接，返回客户端Socket  
          clientSockets.Add(clientSocket); // 存入列表  
          // 可选：发送欢迎消息  
          clientSocket.Send(Encoding.UTF8.GetBytes("欢迎连入服务器"));  
      }  
  }  
  ```  


### **3. 多线程+线程池处理消息收发（多客户端通信）**  
**问题**：需同时接收多个客户端的消息，且避免处理某条消息耗时影响其他消息。  
**解决**：  
- 单独线程循环检测所有客户端消息；  
- 收到消息后通过**线程池**异步处理（避免阻塞检测线程，提升性能）。  


#### **3.1 接收消息线程（循环检测所有客户端）**  
- **创建“接收消息”线程**：  
  ```csharp
  Thread receiveThread = new Thread(ReceiveMessage); // ReceiveMessage为处理消息接收的方法  
  receiveThread.Start();  
  ```  
- **线程方法逻辑（死循环检测消息）**：  
  ```csharp
  static void ReceiveMessage() {  
      // 预定义变量，减少GC 
      byte[] result = new byte[1024 * 1024];  
      int receiveLength;  
      int i;
      Socket clientSocket;
      while (!isClose) {  
          for (i = 0; i < clientSockets.Count; i++) { // 遍历所有客户端Socket  
              clientSocket = clientSockets[i];  
              // 优化：先判断是否有消息待接收（避免无效调用）  
              if (clientSocket.Available > 0) { // Available返回可接收的字节数，>0则有消息  
                  receiveLength = clientSocket.Receive(result); // 接收消息  
                  if (receiveLength > 0) {  
                      // 收到消息后，通过线程池处理（避免阻塞检测线程同时提高性能）  
                      // 暂时使用元组简化传参
                      ThreadPool.QueueUserWorkItem(HandleMessage, (clientSocket, Encoding.UTF8.GetString(result, 0, receiveLength)));  
                  }  
              }  
          }  
      }  
  }  
  ```  

#### **3.2 线程池处理消息（避免阻塞检测线程）**  
**问题**：若直接在处理消息时执行复杂逻辑（如数据库操作），会阻塞接收线程，导致其他客户端消息延迟。  
**解决**：通过`ThreadPool.QueueUserWorkItem`将消息处理逻辑抛给线程池，异步执行。  

- **消息处理方法**：  
  ```csharp
  static void HandleMessage(object obj) {  
      var (clientSocket, msg) = ((Socket, string))obj; // 解析参数（客户端Socket+消息内容）  
      Console.WriteLine($"收到客户端[{clientSocket.RemoteEndPoint}]发来的消息：{msg}");  
      // 后续可扩展：根据消息内容执行复杂逻辑（如计算、数据库操作），不影响接收线程  
  }  
  ```  


### **4. 关闭资源与命令控制**  
- **控制台命令控制**：通过控制台输入命令管理服务器（如退出、广播消息）。  
  - **退出服务器**：输入`quit`，设置`isClose=true`，关闭所有客户端连接并清理资源：  
    ```csharp
    if (input == "quit") {  
        isClose = true;  
        foreach (var socket in clientSockets) {  
            socket.Shutdown(SocketShutdown.Both);  
            socket.Close();  
        }  
        clientSockets.Clear();  
        serverSocket.Close();  
    }  
    ```  
  - **广播消息**：输入`b:xxx`（如`b:大家好`），向所有客户端发送消息：  
    ```csharp
    else if (input.StartsWith("b:")) {  
        string broadcastMsg = input.Substring(2); // 截取"b:"后的内容  
        byte[] data = Encoding.UTF8.GetBytes(broadcastMsg);  
        foreach (var socket in clientSockets) {  
            socket.Send(data);  
        }  
    }  
    ```  

### **5. OOP优化**

客户端类封装（ClientSocket）
```csharp
public class ClientSocket
{
    public int clientID;
    public Socket socket;
    public bool isConnected => socket.Connected;

    public ClientSocket(Socket socket)
    {...}
    
    public void Send(string info)
    {...}
    public void Receive()
    {...}
    public void MsgHandle(object obj)
    {...}
    public void Close()
    {...}
}
```

服务端类封装（ServerSocket）
```csharp
public class ServerSocket
{
    public Socket serverSocket;
    public Dictionary<int, ClientSocket> clientSockets = new(); // int 为客户端Id
    public int clientID = 0;
    public bool isClose = false;
    public ServerSocket(int port)
    {...}
    // 开启服务器
    public void Start()
    {...}
    // 监听客户端连接
    public void Accept()
    {...}
    // 监听客户端消息
    public void Receive()
    {...}
    // 关闭服务器
    public void Close()
    {...}
}
```
## 客户端主动断开

:::info
客户端主动退出时（调用`socket.Shutdown()`和`socket.Close()`），服务器端无法通过`socket.Connected`属性准确判断连接已断开。因`Connected`仅反映**上一次收发消息是否成功**，若客户端未主动发送/接收消息即断开（如强制关闭应用），服务器端仍会认为连接有效，导致资源无法及时释放。
:::  

### **一、现有方案的局限性**  
1. **直接关闭Socket**：客户端调用`Shutdown()`和`Close()`后，服务器端`Connected`状态仍为`true`，无法触发断开逻辑。  
2. **使用`Disconnect()`方法**：客户端调用`socket.Disconnect(false)`（标记Socket不再使用），但服务器端`Connected`状态仍未及时更新，无法准确判断断开。  
:::hint
属性 [`Connected`](https://learn.microsoft.com/zh-cn/dotnet/api/system.net.sockets.socket.connected?view=net-10.0#system-net-sockets-socket-connected) 获取自上次 I/O 操作起的连接状态 Socket 。 当它返回 false时， Socket 要么从未连接，要么不再连接。 <br>
Connected不是线程安全;<br>
当从另一个线程断开连接时，操作中止后，Socket它可能会返回 true 。
:::

---

### **二、解决方案：自定义退出消息**  
通过**客户端发送自定义退出消息**，服务器端收到后主动释放连接，确保断开逻辑的可靠性。  
**实现步骤：**
1. 定义退出消息类（QuitMessage）
2. 客户端发送退出消息
3. 服务器端处理退出消息