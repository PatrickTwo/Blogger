## TCP通信同步方案·服务端实现

---

### **一、开发环境与项目准备**  
- **环境选择**：服务端使用**控制台程序**即可，无需Unity。  
- **项目创建**：新建控制台应用（如命名为`TeachTCPServer`），框架选`.NET Core 3.1`（避免VS2022顶级语法省略，建议手动补全代码）。  
- **基础代码**：初始打印“按任意键退出”并阻塞（`Console.ReadKey()`），防止程序自动关闭。  

---

### **二、服务端核心流程**  
服务端需完成以下步骤：  
1. **创建套接字**：实例化TCP Socket对象。  
2. **绑定地址**：将Socket与本机IP和端口绑定（`Bind`方法）。  
3. **监听连接**：设置最大客户端连接数（`Listen`方法）。  
4. **接受连接**：阻塞等待客户端连接（`Accept`方法，返回新Socket用于通信）。  
5. **收发数据**：通过新Socket的`Send`（发送）和`Receive`（接收）方法与客户端交互。  
6. **关闭连接**：调用`Shutdown`释放连接，再调用`Close`彻底关闭Socket。  

---

### **三、服务端代码实现（分步详解）**  

#### **1. 创建TCP套接字**  
```csharp
// 声明TCP套接字（IPv4寻址、流类型、TCP协议）
Socket socketTcp = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
```  

#### **2. 绑定本地地址（IP+端口）**  
- **IPEndPoint对象**：指定本机IP（如`127.0.0.1`）和端口（>1024且未被占用，如`8080`）。  
- **异常处理**：绑定可能因IP/端口非法或占用失败，需用`try-catch`捕获错误。  
```csharp
IPEndPoint ipEndPoint = new IPEndPoint(IPAddress.Parse("127.0.0.1"), 8080);
try {
    socketTcp.Bind(ipEndPoint); // 绑定IP和端口
} catch (Exception ex) {
    Console.WriteLine($"绑定报错：{ex.Message}");
    return; // 绑定失败则终止后续逻辑
}
```  

#### **3. 监听客户端连接**  
- **Listen方法**：设置最大连接数（如`1024`，根据实际需求调整）。  
- **提示信息**：绑定和监听成功后打印状态。  
```csharp
socketTcp.Listen(1024); // 最大允许1024个客户端连接
Console.WriteLine("服务端绑定监听结束，等待客户端连入...");
```  

#### **4. 接受客户端连接（阻塞式）**  
- **Accept方法**：阻塞主线程，直到有客户端连接；返回新Socket（`socketClient`）用于与该客户端通信。  
- **验证阻塞特性**：通过断点或逐行调试观察，执行到`Accept`时会暂停，直到客户端连接后才继续。  
```csharp
Socket socketClient = socketTcp.Accept(); // 阻塞等待客户端连接
Console.WriteLine("有客户端连入！"); // 此句需客户端连接后才会执行
```  

#### **5. 收发数据（同步方法）**  
- **发送数据**：`Send`方法需将字符串转为UTF-8字节数组（网络通信推荐编码）。  
  ```csharp
  string welcomeMsg = "欢迎连入啊服务端";
  byte[] sendData = System.Text.Encoding.UTF8.GetBytes(welcomeMsg);
  socketClient.Send(sendData); // 发送欢迎消息
  ```  
- **接收数据**：`Receive`方法需预先声明字节数组作为缓存，返回值为实际接收的字节数（关键！用于解析有效数据）。  
  ```csharp
  byte[] receiveBuffer = new byte[1024]; // 1KB缓存
  int receiveLength = socketClient.Receive(receiveBuffer); // 接收数据，返回字节数
  // 解析接收的字符串（从0开始，长度为receiveLength）
  string receivedMsg = Encoding.UTF8.GetString(receiveBuffer, 0, receiveLength);
  // 打印客户端IP和消息
  Console.WriteLine($"接收到客户端[{socketClient.RemoteEndPoint}]的消息：{receivedMsg}");
  ```  

#### **6. 关闭连接**  
- **Shutdown**：停止收发（`SocketShutdown.Both`表示同时停止发送和接收）。  
- **Close**：释放Socket资源，彻底关闭连接（注意：关闭的是与客户端通信的`socketClient`，而非服务端的`socketTcp`）。  
```csharp
socketClient.Shutdown(SocketShutdown.Both); // 停止收发
socketClient.Close(); // 关闭连接
```  

---

### **四、关键注意事项**  
1. **同步方法的阻塞性**：`Accept`、`Receive`均为阻塞式方法，会暂停主线程直到操作完成（如等待连接或数据）。  
2. **接收数据的解析**：`Receive`的返回值是实际接收的字节数，需用此值截取有效数据（避免解析无效缓存）。  
3. **多客户端支持**：当前代码仅能处理单个客户端连接，后续需通过多线程/异步解决多客户端并发问题（本节课未涉及）。  

---


## TCP通信同步方案·客户端实现

---

### **一、客户端核心流程**  
客户端需完成以下步骤（本节课重点实现）：  
1. **创建套接字**：实例化TCP Socket对象（与服务端类型一致）。  
2. **连接服务端**：通过`Connect`方法连接服务端（需服务端IP和端口）。  
3. **收发数据**：使用`Send`（发送）和`Receive`（接收）方法与服务端交互。  
4. **关闭连接**：调用`Shutdown`释放连接，再调用`Close`彻底关闭Socket。  

---

### **二、客户端代码实现（分步详解）**  

#### **1. 创建TCP套接字**  
与服务端一致，使用IPv4寻址、流类型、TCP协议：  
```csharp
// 声明TCP套接字（IPv4寻址、流类型、TCP协议）
Socket socketClient = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
```  

#### **2. 连接服务端（关键步骤）**  
- **IPEndPoint对象**：指定服务端IP（本机开发时为`127.0.0.1`，远端服务器为实际IP）和端口（如`8080`）。  
- **异常处理**：连接失败可能因服务端未启动或拒绝连接（错误码`10061`表示服务器拒绝），需用`try-catch`捕获`SocketException`。  
```csharp
IPEndPoint serverEndPoint = new IPEndPoint(IPAddress.Parse("127.0.0.1"), 8080); // 服务端IP和端口
try {
    socketClient.Connect(serverEndPoint); // 连接服务端
} 
catch (SocketException ex) {
    Console.WriteLine($"连接服务器失败，错误码：{ex.ErrorCode}");
    return; // 连接失败则终止后续逻辑
}
```  

#### **3. 接收服务端数据**  
- **Receive方法**：需预先声明字节数组作为缓存，返回值为实际接收的字节数（关键！用于解析有效数据）。  
- **编码转换**：网络通信推荐使用UTF-8编码，将字节数组转为字符串。  
```csharp
byte[] receiveBuffer = new byte[1024]; // 1KB缓存
int receiveLength = socketClient.Receive(receiveBuffer); // 接收数据，返回字节数
string receivedMsg = UTF8.GetString(receiveBuffer, 0, receiveLength);
Console.WriteLine($"收到服务端消息：{receivedMsg}");
```  

#### **4. 发送数据到服务端**  
- **Send方法**：将字符串转为UTF-8字节数组后发送。  
```csharp
string sendMsg = "这是客户端";
byte[] sendData = Encoding.UTF8.GetBytes(sendMsg);
socketClient.Send(sendData); // 发送消息
```  

#### **5. 关闭连接**  
与服务端一致，先停止收发再关闭：  
```csharp
socketClient.Shutdown(SocketShutdown.Both); // 停止收发
socketClient.Close(); // 关闭连接
```  

---


### **三、关键注意事项**  
1. **连接IP的区别**：客户端`Connect`的IP是**服务端IP**（本机开发时为`127.0.0.1`，非客户端自身IP）。  
2. **同步方法的阻塞性**：`Connect`、`Receive`、`Send`均为阻塞式方法，会暂停主线程直到操作完成（如等待连接或数据）。  
3. **客户端与服务端的Socket差异**：  
   - 服务端：`Accept`返回新Socket用于与客户端通信（原Socket继续监听）。  
   - 客户端：始终使用自身创建的Socket（`socketClient`）与服务端通信。  

---

## **服务端示例**

:::info
功能实现：  
1. 允许多个客户端连入服务器；  
2. 可分别与多个客户端通信（收发消息）。  
:::

实现步骤
- 建立Socket、绑定、监听
- 等待连接
- 收发消息
- 关闭资源

### **1. Socket初始化**  
声明静态Socket（供多线程访问）：
`static Socket serverSocket;`  
```csharp
// 创建Socket
serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
// 绑定IP和端口
serverSocket.Bind(new IPEndPoint(IPAddress.Parse("127.0.0.1"), 8080));
// 监听连接（1024为最大挂起连接数，实际通过逻辑控制连接数）  
serverSocket.Listen(1024);
```

### **2. 多线程处理客户端连接（允许多客户端接入）**  
**问题**：单线程`Accept()`是阻塞函数，会阻塞代码执行。  
**解决**：单独开线程循环调用`Accept()`，持续监听新连接，将客户端Socket存入列表。  

**实现**：  
- **客户端Socket列表**：
`static List<Socket> clientSockets = new List<Socket>();`（存储所有连接的客户端Socket）。  
- **创建“接受连接”线程**：  
  ```csharp
  Thread acceptThread = new Thread(AcceptClientConnect); // AcceptClientConnect为处理连接的方法  
  acceptThread.Start();  
  ```  
- **线程方法逻辑（死循环监听连接）**：  
  ```csharp
  static void AcceptClientConnect() {  
      while (!isClose) { // isClose为控制线程退出的标志（布尔值，默认false）  
          Socket clientSocket = serverSocket.Accept(); // 阻塞等待客户端连接，返回客户端Socket  
          clientSockets.Add(clientSocket); // 存入列表  
          // 可选：发送欢迎消息  
          clientSocket.Send(Encoding.UTF8.GetBytes("欢迎连入服务器"));  
      }  
  }  
  ```  


### **3. 多线程+线程池处理消息收发（多客户端通信）**  
**问题**：需同时接收多个客户端的消息，且避免处理某条消息耗时影响其他消息。  
**解决**：  
- 单独线程循环检测所有客户端消息；  
- 收到消息后通过**线程池**异步处理（避免阻塞检测线程，提升性能）。  


#### **3.1 接收消息线程（循环检测所有客户端）**  
- **创建“接收消息”线程**：  
  ```csharp
  Thread receiveThread = new Thread(ReceiveMessage); // ReceiveMessage为处理消息接收的方法  
  receiveThread.Start();  
  ```  
- **线程方法逻辑（死循环检测消息）**：  
  ```csharp
  static void ReceiveMessage() {  
      // 预定义变量，减少GC 
      byte[] result = new byte[1024 * 1024];  
      int receiveLength;  
      int i;
      Socket clientSocket;
      while (!isClose) {  
          for (i = 0; i < clientSockets.Count; i++) { // 遍历所有客户端Socket  
              clientSocket = clientSockets[i];  
              // 优化：先判断是否有消息待接收（避免无效调用）  
              if (clientSocket.Available > 0) { // Available返回可接收的字节数，>0则有消息  
                  receiveLength = clientSocket.Receive(result); // 接收消息  
                  if (receiveLength > 0) {  
                      // 收到消息后，通过线程池处理（避免阻塞检测线程同时提高性能）  
                      // 暂时使用元组简化传参
                      ThreadPool.QueueUserWorkItem(HandleMessage, (clientSocket, Encoding.UTF8.GetString(result, 0, receiveLength)));  
                  }  
              }  
          }  
      }  
  }  
  ```  

#### **3.2 线程池处理消息（避免阻塞检测线程）**  
**问题**：若直接在处理消息时执行复杂逻辑（如数据库操作），会阻塞接收线程，导致其他客户端消息延迟。  
**解决**：通过`ThreadPool.QueueUserWorkItem`将消息处理逻辑抛给线程池，异步执行。  

- **消息处理方法**：  
  ```csharp
  static void HandleMessage(object obj) {  
      var (clientSocket, msg) = ((Socket, string))obj; // 解析参数（客户端Socket+消息内容）  
      Console.WriteLine($"收到客户端[{clientSocket.RemoteEndPoint}]发来的消息：{msg}");  
      // 后续可扩展：根据消息内容执行复杂逻辑（如计算、数据库操作），不影响接收线程  
  }  
  ```  


### **4. 关闭资源与命令控制**  
- **控制台命令控制**：通过控制台输入命令管理服务器（如退出、广播消息）。  
  - **退出服务器**：输入`quit`，设置`isClose=true`，关闭所有客户端连接并清理资源：  
    ```csharp
    if (input == "quit") {  
        isClose = true;  
        foreach (var socket in clientSockets) {  
            socket.Shutdown(SocketShutdown.Both);  
            socket.Close();  
        }  
        clientSockets.Clear();  
        serverSocket.Close();  
    }  
    ```  
  - **广播消息**：输入`b:xxx`（如`b:大家好`），向所有客户端发送消息：  
    ```csharp
    else if (input.StartsWith("b:")) {  
        string broadcastMsg = input.Substring(2); // 截取"b:"后的内容  
        byte[] data = Encoding.UTF8.GetBytes(broadcastMsg);  
        foreach (var socket in clientSockets) {  
            socket.Send(data);  
        }  
    }  
    ```  

### **5. OOP优化**

客户端类封装（ClientSocket）
```csharp
public class ClientSocket
{
    public int clientID;
    public Socket socket;
    public bool isConnected => socket.Connected;

    public ClientSocket(Socket socket)
    {...}
    
    public void Send(string info)
    {...}
    public void Receive()
    {...}
    public void MsgHandle(object obj)
    {...}
    public void Close()
    {...}
}
```

服务端类封装（ServerSocket）
```csharp
public class ServerSocket
{
    public Socket serverSocket;
    public Dictionary<int, ClientSocket> clientSockets = new(); // int 为客户端Id
    public int clientID = 0;
    public bool isClose = false;
    public ServerSocket(int port)
    {...}
    // 开启服务器
    public void Start()
    {...}
    // 监听客户端连接
    public void Accept()
    {...}
    // 监听客户端消息
    public void Receive()
    {...}
    // 关闭服务器
    public void Close()
    {...}
}
```
## **客户端示例**

:::info
功能实现：  
1. 客户端网络连接不影响主线程；  
2. 可随时与服务端通信（收发消息）。  
:::

### **一、核心思路**  
通过网络模块封装，将**连接、发送、接收**逻辑与主线程解耦：  
- **发送消息**：主线程将消息放入队列，独立线程从队列取消息发送（避免 Send 阻塞主线程）；  
- **接收消息**：独立线程接收消息并放入队列，主线程（Update）从队列取消息处理（避免子线程直接操作 Unity 主线程对象）。  


### **二、NetManager**  
单例管理器（这里省略了单例的实现），负责客户端网络通信全流程管理。  

#### **1. 成员变量**  
- **客户端 Socket**：`private Socket clientSocket;`（管理网络连接）；  
- **发送消息队列**：`private Queue<string> sendMsgQueue = new Queue<string>();`（主线程放消息，发送线程取消息）；  
- **接收消息队列**：`private Queue<string> receiveMsgQueue = new Queue<string>();`（接收线程放消息，主线程取消息）；  
- **连接状态**：`private bool isConnected = false;`（控制线程启停）；  
- **接收缓冲区**：`private byte[] receiveBytes = new byte[1024 * 1024];`（1M 预分配，减少 GC）；  
- **接收字节数**：`private int receiveLength;`（记录实际接收字节数）。  


#### **2. 核心方法**  

##### **（1）连接服务端**  
```csharp
public void Connect(string ip, int port) {  
    if (isConnected) return; // 已连接则直接返回  
    if (clientSocket == null)
        clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
    try {  
        clientSocket.Connect(new IPEndPoint(IPAddress.Parse(ip), port));  
        isConnected = true;  
        ThreadPool.QueueUserWorkItem(SendMessageLoop); // 放入线程池管理
        ThreadPool.QueueUserWorkItem(ReceiveMessageLoop); // 放入线程池管理   
    } catch (SocketException e) {  
        Debug.LogError($"连接失败：错误码={e.ErrorCode}，信息={e.Message}");  
    }  
}  
```  

##### **（2）发送消息（主线程调用，放入队列）**  
主线程调用 `Send` 仅将消息入队，不阻塞：  
```csharp
// 以字符串为例
public void Send(string msg) {  
    if (!string.IsNullOrEmpty(msg)) {  
        sendMsgQueue.Enqueue(msg); // 消息入队，由发送线程处理实际发送  
    }  
}  
```  

##### **（3）发送线程逻辑（从队列取消息发送）**  
独立线程循环检测发送队列，有消息则发送（避免主线程阻塞）：  
```csharp
private void SendMessageLoop(object obj) {  
    while (isConnected) {  
        if (sendMsgQueue.Count > 0) {  
            string msg = sendMsgQueue.Dequeue();  
            byte[] data = Encoding.UTF8.GetBytes(msg);  
            clientSocket?.Send(data); // 实际发送（子线程执行，不阻塞主线程）  
        }  
    }  
}  
```  

##### **（4）接收线程逻辑（接收消息入队）**  
独立线程循环接收消息，解析后入队（避免主线程阻塞）：  
```csharp
private void ReceiveMessageLoop(object obj) {  
    while (isConnected) {  
        if (clientSocket?.Available > 0) { // 优化：先判断是否有消息待接收  
            receiveLength = clientSocket.Receive(receiveBytes);  
            if (receiveLength > 0) {  
                string msg = Encoding.UTF8.GetString(receiveBytes, 0, receiveLength);  
                receiveMsgQueue.Enqueue(msg); // 消息入队，主线程 Update 处理  
            }  
        }  
    }  
}  
```  


##### **（5）主线程处理接收消息（Update 中取队列消息）**  
主线程在 `Update` 中检测接收队列，取出消息并处理（避免子线程直接操作 Unity 对象）：  
```csharp
private void Update() {  
    while (receiveMsgQueue.Count > 0) {  
        string msg = receiveMsgQueue.Dequeue();  
        Debug.Log($"收到服务端消息：{msg}");  
        // 后续可扩展：根据消息类型操作场景对象（如移动、UI更新等）  
    }  
}  
```  


##### **（6）关闭连接**  
停止线程并释放资源：  
```csharp
public void Close() {  
    isConnected = false;  
    clientSocket?.Shutdown(SocketShutdown.Both);  
    clientSocket?.Close();  
    clientSocket = null;  
}  

private void OnDestroy() {  
    Close(); // 对象销毁时关闭连接  
}  
```  


#### **4. 主入口（Main 脚本）**  
确保 `NetManager` 唯一且跨场景可用：  
```csharp
public class Main : MonoBehaviour {  
    void Start() {  
        if (NetManager.Instance == null) {  
            GameObject netObj = new GameObject("NetManager");  
            netObj.AddComponent<NetManager>();  
        }  
        // 连接服务端（示例：本地 8080 端口）  
        NetManager.Instance.Connect("127.0.0.1", 8080);  
    }  
}  
```  


#### **5. UI 交互测试（发送消息）**  
通过 UI 按钮触发发送消息：  
- 创建 InputField（输入框）和 Button（发送按钮）；  
- 挂载脚本监听按钮点击事件，调用 `NetManager.Instance.Send(input.text)`：  
```csharp
public class TestUI : MonoBehaviour {  
    public InputField input;  
    public Button sendBtn;  

    void Start() {  
        sendBtn.onClick.AddListener(() => {  
            if (!string.IsNullOrEmpty(input.text)) {  
                NetManager.Instance.Send(input.text);  
            }  
        });  
    }  
}  
```  