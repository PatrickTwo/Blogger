### C# 中的回调（Callback）

回调（Callback）是一种常见的编程模式，指的是将一个方法作为参数传递给另一个方法，并在特定时机调用这个方法。在 C# 中，回调主要通过 **委托（Delegate）、事件（Event）和 Lambda 表达式** 实现。

---

## 1. **使用委托（Delegate）实现回调**
委托是 C# 中用于表示方法的引用类型，可以用来实现回调机制。

### **基本示例**
```csharp
using System;

public class Program
{
    // 定义一个委托
    public delegate void CallbackDelegate(string message);

    // 这个方法接受一个委托作为参数
    public static void ProcessData(CallbackDelegate callback)
    {
        Console.WriteLine("正在处理数据...");
        // 处理完数据后，执行回调
        callback("数据处理完成！");
    }

    // 回调方法
    public static void ShowMessage(string message)
    {
        Console.WriteLine($"回调消息: {message}");
    }

    public static void Main()
    {
        // 传递回调方法
        ProcessData(ShowMessage);
    }
}
```
**输出：**
```
正在处理数据...
回调消息: 数据处理完成！
```

### **使用匿名方法**
C# 允许使用匿名方法作为回调，减少代码量：
```csharp
ProcessData(delegate (string msg) { Console.WriteLine($"回调消息: {msg}"); });
```

### **使用 Lambda 表达式**
Lambda 使代码更简洁：
```csharp
ProcessData(msg => Console.WriteLine($"回调消息: {msg}"));
```

---

## 2. **使用事件（Event）实现回调**
事件是基于委托的一种封装，用于 **观察者模式（Observer Pattern）**。

### **示例**
```csharp
using System;

public class DataProcessor
{
    // 定义委托
    public delegate void ProcessCompletedEventHandler(string result);
    
    // 定义事件
    public event ProcessCompletedEventHandler ProcessCompleted;

    public void StartProcess()
    {
        Console.WriteLine("开始处理...");
        System.Threading.Thread.Sleep(1000); // 模拟耗时任务
        OnProcessCompleted("处理完成！");
    }

    protected virtual void OnProcessCompleted(string result)
    {
        ProcessCompleted?.Invoke(result); // 触发事件
    }
}

public class Program
{
    public static void Main()
    {
        DataProcessor processor = new DataProcessor();
        // 订阅事件
        processor.ProcessCompleted += msg => Console.WriteLine($"事件回调: {msg}");
        processor.StartProcess();
    }
}
```
**输出：**
```
开始处理...
事件回调: 处理完成！
```
> **事件的好处**：可以有多个订阅者，适用于多对多的回调场景。

---

## 3. **Func 和 Action 回调**(需要引入System命名空间)
C# 提供了内置委托 **Func** 和 **Action**，可以简化回调函数的声明。

### **使用 `Action<T>`（无返回值的回调）**
```csharp
using System;

public class Program
{
    public static void ProcessData(Action<string> callback)
    {
        Console.WriteLine("正在处理数据...");
        callback("数据已处理！");
    }

    public static void Main()
    {
        ProcessData(msg => Console.WriteLine($"回调: {msg}"));
    }
}
```

### **使用 `Func<T, TResult>`（有返回值的回调）**
```csharp
using System;

public class Program
{
    public static int Compute(Func<int, int, int> callback, int a, int b)
    {
        return callback(a, b);
    }

    public static void Main()
    {
        int result = Compute((x, y) => x + y, 3, 5);
        Console.WriteLine($"回调计算结果: {result}");
    }
}
```
**输出：**
```
回调计算结果: 8
```
---

## 4. **异步回调（Async Callback）**
在异步编程中，回调可以用于任务完成后的处理。

### **使用 `Task` 进行异步回调**
```csharp
using System;
using System.Threading.Tasks;

public class Program
{
    public static async Task ProcessAsync(Func<Task> callback)
    {
        Console.WriteLine("异步处理开始...");
        await Task.Delay(1000); // 模拟耗时操作
        await callback();
    }

    public static async Task Main()
    {
        await ProcessAsync(async () => {
            await Task.Delay(500);
            Console.WriteLine("异步回调执行！");
        });
    }
}
```
**输出：**
```
异步处理开始...
异步回调执行！
```

---

## 5. **回调的应用场景**
- **异步任务通知**（如：I/O 操作、网络请求）
- **事件驱动开发**（如：按钮点击事件）
- **策略模式**（如：提供不同的算法选择）
- **中间件机制**（如：ASP.NET Core 中间件）

---

## 6. **总结**
| 方式 | 适用场景 | 优点 | 缺点 |
|------|------|------|------|
| **委托 (Delegate)** | 简单的同步回调 | 代码清晰、灵活 | 不能直接用于事件订阅 |
| **事件 (Event)** | 多个订阅者的通知机制 | 适合观察者模式 | 不能直接赋值，只能 `+=` 订阅 |
| **Lambda 表达式** | 简化回调代码 | 代码更简洁 | 可读性下降 |
| **Action / Func** | 处理无/有返回值的回调 | 避免自定义委托 | 只适用于单一方法 |
| **异步回调 (Task)** | 处理异步任务 | 适合 I/O 密集型任务 | 需要 `async/await` |

C# 的回调机制提供了多种实现方式，可以根据具体需求选择合适的方法。