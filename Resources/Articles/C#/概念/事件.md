Unity中的事件系统通常基于C#的委托（Delegate）和事件（Event）机制。

**使用事件的基本步骤**
1. 定义委托：首先定义一个委托，它指定了事件处理方法的签名。
2. 声明事件：在类中声明一个事件，使用event关键字和之前定义的委托类型。
3. 触发事件：在适当的时机触发事件，通常是在某个条件满足或某个动作发生时。
4. 订阅事件：在其他类中订阅这个事件，提供一个方法来处理事件。
5. 取消订阅事件：在不需要时取消订阅事件，以避免内存泄漏。

**Unity中的内置事件**
Unity还提供了一些内置的事件系统，例如：
- UnityEvent：这是一个序列化的委托，可以在Inspector中直接配置。
- UI事件：例如Button.onClick，可以在Inspector中直接绑定方法。
- EventHandler:  C# 中用于处理事件的标准委托类型 `public delegate void EventHandler(object sender, EventArgs e);`

# 静态事件与普通事件的区别


静态事件（`static event`）与普通事件（`instance event`）的主要区别在于它们的作用域和生命周期：

1. **作用域**：
   - **静态事件**：属于类本身，而不是类的实例。这意味着无论类有多少个实例，静态事件只有一个，并且可以在没有类实例的情况下被触发或订阅。静态事件通常用于跨实例的通信或全局通知。
   - **普通事件**：属于类的实例。每个类的实例都有自己的事件，事件的生命周期与实例的生命周期相同。普通事件通常用于实例内部的通信或通知。

2. **生命周期**：
   - **静态事件**：生命周期与应用程序域（AppDomain）相同，直到应用程序结束或类被卸载时才会被销毁。静态事件在类的所有实例之间共享。
   - **普通事件**：生命周期与实例相同，当实例被销毁时，事件也会随之销毁。普通事件只能在实例存在时被触发或订阅。

3. **内存管理**：
   - **静态事件**：由于静态事件的生命周期较长，如果不小心处理订阅和取消订阅，可能会导致内存泄漏。例如，如果订阅者没有取消订阅，订阅者对象将无法被垃圾回收。
   - **普通事件**：由于普通事件的生命周期与实例相同，通常不会导致内存泄漏问题，除非订阅者没有正确取消订阅。

4. **使用场景**：
   - **静态事件**：适用于需要在类的所有实例之间共享的事件，或者在没有实例的情况下触发事件。例如，全局的通知系统或跨实例的状态同步。
   - **普通事件**：适用于实例内部的状态变化通知，或者实例之间的通信。

在你的代码中，`OnAnyActionPointsChanged` 是一个静态事件，用于在所有 `Unit` 实例之间共享动作点数变化的信息。无论有多少个 `Unit` 实例，只要触发了这个事件，所有订阅了该事件的监听者都会收到通知。这种设计使得跨实例的通信更加方便和高效。
