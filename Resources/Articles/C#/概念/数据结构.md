在C#中，常用的数据容器包括数组、列表、字典、集合等。以下是这些容器的常用操作：

- [1. 数组 (`Array`)](#1-数组-array)
- [2. 列表 (`List<T>`)](#2-列表-listt)
- [3. 字典 (`Dictionary<TKey, TValue>`)](#3-字典-dictionarytkey-tvalue)
- [4. 集合 (`HashSet<T>`)](#4-集合-hashsett)
- [5. 队列 (`Queue<T>`)](#5-队列-queuet)
- [6. 栈 (`Stack<T>`)](#6-栈-stackt)
- [7. 链表 (`LinkedList<T>`)](#7-链表-linkedlistt)
- [8. 有序集合 (`SortedSet<T>`)](#8-有序集合-sortedsett)
- [9. 有序字典 (`SortedDictionary<TKey, TValue>`)](#9-有序字典-sorteddictionarytkey-tvalue)
- [10. 只读集合 (`ReadOnlyCollection<T>`)](#10-只读集合-readonlycollectiont)
- [11. 并发集合 (`ConcurrentBag<T>`, `ConcurrentQueue<T>`, `ConcurrentStack<T>`, `ConcurrentDictionary<TKey, TValue>`)](#11-并发集合-concurrentbagt-concurrentqueuet-concurrentstackt-concurrentdictionarytkey-tvalue)

### 1. 数组 (`Array`)
数组是固定大小的数据容器，存储相同类型的元素。

**常用操作：**
- 声明和初始化：
  ```csharp
  int[] numbers = new int[5]; // 声明一个长度为5的整数数组
  int[] numbers = { 1, 2, 3, 4, 5 }; // 声明并初始化数组
  ```
- 访问元素：
  ```csharp
  int firstElement = numbers[0]; // 访问第一个元素
  ```
- 修改元素：
  ```csharp
  numbers[0] = 10; // 修改第一个元素
  ```
- 遍历数组：
  ```csharp
  foreach (int number in numbers)
  {
      Console.WriteLine(number);
  }
  ```
- 获取数组长度：
  ```csharp
  int length = numbers.Length;
  ```

### 2. 列表 (`List<T>`)
列表是动态数组，可以动态调整大小。

**常用操作：**
- 声明和初始化：
  ```csharp
  List<int> numbers = new List<int>(); // 声明一个整数列表
  List<int> numbers = new List<int> { 1, 2, 3, 4, 5 }; // 声明并初始化列表
  ```
- 添加元素：
  ```csharp
  numbers.Add(6); // 在列表末尾添加元素
  ```
- 插入元素：
  ```csharp
  numbers.Insert(0, 0); // 在指定位置插入元素
  ```
- 删除元素：
  ```csharp
  numbers.Remove(3); // 删除第一个匹配的元素
  numbers.RemoveAt(0); // 删除指定位置的元素
  ```
- 访问元素：
  ```csharp
  int firstElement = numbers[0]; // 访问第一个元素
  ```
- 遍历列表：
  ```csharp
  foreach (int number in numbers)
  {
      Console.WriteLine(number);
  }
  ```
- 获取列表长度：
  ```csharp
  int count = numbers.Count;
  ```
- 检查列表中是否存在某个元素：
    Contains 方法：
    ```csharp
    List<int> list = new List<int> { 1, 2, 3, 4, 5 };
    int elementToFind = 3;
    bool isContained = list.Contains(elementToFind);
    Console.WriteLine(isContained); // 输出: True
    ```
    IndexOf 方法：
    ```csharp
    List<int> list = new List<int> { 1, 2, 3, 4, 5 };
    int elementToFind = 3;
    int index = list.IndexOf(elementToFind);
    bool isContained = index != -1;
    Console.WriteLine(isContained); // 输出: True
    ```

> 1. List中可以添加重复的元素（List 是一个 ​有序的集合，它通过 ​索引​ 来管理元素）


### 3. 字典 (`Dictionary<TKey, TValue>`)
字典是键值对的集合，键必须是唯一的。

**常用操作：**
- 声明和初始化：
  ```csharp
  Dictionary<string, int> ages = new Dictionary<string, int>(); // 声明一个字典
  Dictionary<string, int> ages = new Dictionary<string, int> { { "Alice", 25 }, { "Bob", 30 } }; // 声明并初始化字典
  ```
- 添加键值对：
  ```csharp
  ages.Add("Charlie", 35); // 添加键值对
  ```
- 访问元素：
  ```csharp
  int aliceAge = ages["Alice"]; // 通过键访问值
  ```
- 修改元素：
  ```csharp
  ages["Alice"] = 26; // 修改键对应的值
  ```
- 删除元素：
  ```csharp
  ages.Remove("Bob"); // 删除指定键的键值对
  ```
- 检查键是否存在：
  ```csharp
  bool containsKey = ages.ContainsKey("Alice");
  ```
- 遍历字典：
  ```csharp
  foreach (var kvp in ages)
  {
      Console.WriteLine($"{kvp.Key}: {kvp.Value}");
  }
  ```

### 4. 集合 (`HashSet<T>`)
集合是不包含重复元素的集合。

**常用操作：**
- 声明和初始化：
  ```csharp
  HashSet<int> numbers = new HashSet<int>(); // 声明一个整数集合
  HashSet<int> numbers = new HashSet<int> { 1, 2, 3, 4, 5 }; // 声明并初始化集合
  ```
- 添加元素：
  ```csharp
  numbers.Add(6); // 添加元素
  ```
- 删除元素：
  ```csharp
  numbers.Remove(3); // 删除元素
  ```
- 检查元素是否存在：
  ```csharp
  bool contains = numbers.Contains(4); // 检查元素是否存在
  ```
- 遍历集合：
  ```csharp
  foreach (int number in numbers)
  {
      Console.WriteLine(number);
  }
  ```

### 5. 队列 (`Queue<T>`)
队列是先进先出（FIFO）的数据结构。

**常用操作：**
- 声明和初始化：
  ```csharp
  Queue<int> queue = new Queue<int>(); // 声明一个整数队列
  ```
- 入队：
  ```csharp
  queue.Enqueue(1); // 将元素添加到队列末尾
  ```
- 出队：
  ```csharp
  int firstElement = queue.Dequeue(); // 移除并返回队列开头的元素
  ```
- 查看队首元素：
  ```csharp
  int firstElement = queue.Peek(); // 返回队列开头的元素但不移除
  ```
- 遍历队列：
  ```csharp
  foreach (int number in queue)
  {
      Console.WriteLine(number);
  }
  ```

### 6. 栈 (`Stack<T>`)
栈是后进先出（LIFO）的数据结构。

**常用操作：**
- 声明和初始化：
  ```csharp
  Stack<int> stack = new Stack<int>(); // 声明一个整数栈
  ```
- 入栈：
  ```csharp
  stack.Push(1); // 将元素压入栈顶
  ```
- 出栈：
  ```csharp
  int topElement = stack.Pop(); // 移除并返回栈顶的元素
  ```
- 查看栈顶元素：
  ```csharp
  int topElement = stack.Peek(); // 返回栈顶的元素但不移除
  ```
- 遍历栈：
  ```csharp
  foreach (int number in stack)
  {
      Console.WriteLine(number);
  }
  ```

### 7. 链表 (`LinkedList<T>`)
链表是元素通过指针链接的线性集合。

**常用操作：**
- 声明和初始化：
  ```csharp
  LinkedList<int> list = new LinkedList<int>(); // 声明一个整数链表
  ```
- 添加元素：
  ```csharp
  list.AddLast(1); // 在链表末尾添加元素
  list.AddFirst(0); // 在链表开头添加元素
  ```
- 删除元素：
  ```csharp
  list.Remove(1); // 删除指定元素
  list.RemoveFirst(); // 删除链表开头的元素
  list.RemoveLast(); // 删除链表末尾的元素
  ```
- 遍历链表：
  ```csharp
  foreach (int number in list)
  {
      Console.WriteLine(number);
  }
  ```

### 8. 有序集合 (`SortedSet<T>`)
有序集合是不包含重复元素且元素按顺序排列的集合。

**常用操作：**
- 声明和初始化：
  ```csharp
  SortedSet<int> numbers = new SortedSet<int>(); // 声明一个整数有序集合
  SortedSet<int> numbers = new SortedSet<int> { 5, 3, 1, 4, 2 }; // 声明并初始化有序集合
  ```
- 添加元素：
  ```csharp
  numbers.Add(6); // 添加元素
  ```
- 删除元素：
  ```csharp
  numbers.Remove(3); // 删除元素
  ```
- 检查元素是否存在：
  ```csharp
  bool contains = numbers.Contains(4); // 检查元素是否存在
  ```
- 遍历有序集合：
  ```csharp
  foreach (int number in numbers)
  {
      Console.WriteLine(number);
  }
  ```

### 9. 有序字典 (`SortedDictionary<TKey, TValue>`)
有序字典是按键排序的键值对集合。

**常用操作：**
- 声明和初始化：
  ```csharp
  SortedDictionary<string, int> ages = new SortedDictionary<string, int>(); // 声明一个有序字典
  SortedDictionary<string, int> ages = new SortedDictionary<string, int> { { "Alice", 25 }, { "Bob", 30 } }; // 声明并初始化有序字典
  ```
- 添加键值对：
  ```csharp
  ages.Add("Charlie", 35); // 添加键值对
  ```
- 访问元素：
  ```csharp
  int aliceAge = ages["Alice"]; // 通过键访问值
  ```
- 修改元素：
  ```csharp
  ages["Alice"] = 26; // 修改键对应的值
  ```
- 删除元素：
  ```csharp
  ages.Remove("Bob"); // 删除指定键的键值对
  ```
- 检查键是否存在：
  ```csharp
  bool containsKey = ages.ContainsKey("Alice");
  ```
- 遍历有序字典：
  ```csharp
  foreach (var kvp in ages)
  {
      Console.WriteLine($"{kvp.Key}: {kvp.Value}");
  }
  ```

### 10. 只读集合 (`ReadOnlyCollection<T>`)
只读集合是只读的集合，不能修改。

**常用操作：**
- 声明和初始化：
  ```csharp
  List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };
  ReadOnlyCollection<int> readOnlyNumbers = new ReadOnlyCollection<int>(numbers); // 声明一个只读集合
  ```
- 访问元素：
  ```csharp
  int firstElement = readOnlyNumbers[0]; // 访问第一个元素
  ```
- 遍历只读集合：
  ```csharp
  foreach (int number in readOnlyNumbers)
  {
      Console.WriteLine(number);
  }
  ```

### 11. 并发集合 (`ConcurrentBag<T>`, `ConcurrentQueue<T>`, `ConcurrentStack<T>`, `ConcurrentDictionary<TKey, TValue>`)
并发集合是线程安全的集合，适用于多线程环境。

**常用操作：**
- 声明和初始化：
  ```csharp
  ConcurrentBag<int> bag = new ConcurrentBag<int>(); // 声明一个并发包
  ConcurrentQueue<int> queue = new ConcurrentQueue<int>(); // 声明一个并发队列
  ConcurrentStack<int> stack = new ConcurrentStack<int>(); // 声明一个并发栈
  ConcurrentDictionary<string, int> ages = new ConcurrentDictionary<string, int>(); // 声明一个并发字典
  ```
- 添加元素：
  ```csharp
  bag.Add(1); // 添加元素到并发包
  queue.Enqueue(1); // 入队
  stack.Push(1); // 入栈
  ages.TryAdd("Alice", 25); // 添加键值对到并发字典
  ```
- 删除元素：
  ```csharp
  int result;
  queue.TryDequeue(out result); // 出队
  stack.TryPop(out result); // 出栈
  ages.TryRemove("Alice", out result); // 删除键值对
  ```
- 访问元素：
  ```csharp
  bag.TryPeek(out result); // 查看并发包中的元素
  queue.TryPeek(out result); // 查看队首元素
  stack.TryPeek(out result); // 查看栈顶元素
  ages.TryGetValue("Alice", out result); // 通过键访问值
  ```

这些是C#中常用的数据容器及其常用操作。根据具体需求选择合适的容器可以提高代码的效率和可读性。