**泛型（Generics）** 是 C# 中的一个强大特性，它允许你编写可以与多种数据类型一起工作的类、方法、接口和委托，而无需为每种数据类型重复编写代码。泛型的主要目的是提高代码的**可重用性**、**类型安全性**和**性能**。

---

## 1. 为什么需要泛型？

在没有泛型的情况下，如果你想编写一个可以处理多种数据类型的类或方法，通常需要使用 `object` 类型。然而，这种方式有以下缺点：
1. **类型不安全**：编译器无法检查类型，可能导致运行时错误。
2. **性能问题**：值类型（如 `int`、`double`）需要装箱（boxing）和拆箱（unboxing），影响性能。
3. **代码冗余**：需要为每种数据类型编写重复的代码。

泛型解决了这些问题，它允许你在编译时指定具体的数据类型，从而避免上述问题。

---

## 2. 泛型的基本语法

### 泛型类
泛型类是一个可以接受类型参数的类。类型参数用尖括号 `<T>` 表示，`T` 是占位符，可以在类中用作数据类型。

#### 示例：泛型类
```csharp
using System;

class Box<T>
{
    private T value;

    public Box(T value)
    {
        this.value = value;
    }

    public T GetValue()
    {
        return value;
    }

    public void SetValue(T newValue)
    {
        value = newValue;
    }
}

class Program
{
    static void Main()
    {
        // 使用泛型类存储整数
        Box<int> intBox = new Box<int>(10);
        Console.WriteLine("Value in intBox: " + intBox.GetValue());

        // 使用泛型类存储字符串
        Box<string> stringBox = new Box<string>("Hello");
        Console.WriteLine("Value in stringBox: " + stringBox.GetValue());
    }
}
```

#### 输出
```
Value in intBox: 10
Value in stringBox: Hello
```

#### 说明
- `Box<T>` 是一个泛型类，`T` 是类型参数。
- 在使用时，可以为 `T` 指定具体类型，例如 `Box<int>` 或 `Box<string>`。

---

### 泛型方法
泛型方法是一个可以接受类型参数的方法。类型参数用尖括号 `<T>` 表示，`T` 可以在方法中用作参数类型或返回类型。

#### 示例：泛型方法
```csharp
using System;

class Program
{
    // 泛型方法
    static void PrintValue<T>(T value)
    {
        Console.WriteLine("Value: " + value);
    }

    static void Main()
    {
        // 调用泛型方法
        PrintValue(10);          // T 被推断为 int
        PrintValue("Hello");     // T 被推断为 string
        PrintValue(3.14);        // T 被推断为 double
    }
}
```

#### 输出
```
Value: 10
Value: Hello
Value: 3.14
```

#### 说明
- `PrintValue<T>` 是一个泛型方法，`T` 是类型参数。
- 调用时，编译器会根据传入的参数自动推断 `T` 的类型。

---

### 泛型接口
泛型接口允许你定义可以处理多种数据类型的接口。

#### 示例：泛型接口
```csharp
using System;

interface IRepository<T>
{
    void Add(T item);
    T GetById(int id);
}

class ProductRepository : IRepository<Product>
{
    private List<Product> products = new List<Product>();

    public void Add(Product item)
    {
        products.Add(item);
    }

    public Product GetById(int id)
    {
        return products.FirstOrDefault(p => p.Id == id);
    }
}

class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
}

class Program
{
    static void Main()
    {
        IRepository<Product> repository = new ProductRepository();
        repository.Add(new Product { Id = 1, Name = "Laptop" });

        var product = repository.GetById(1);
        Console.WriteLine("Product Name: " + product.Name);
    }
}
```

#### 输出
```
Product Name: Laptop
```

#### 说明
- `IRepository<T>` 是一个泛型接口，`T` 是类型参数。
- `ProductRepository` 实现了 `IRepository<Product>`，为 `Product` 类型提供了具体的实现。

---

### 泛型委托
泛型委托允许你定义可以处理多种数据类型的委托。

#### 示例：泛型委托
```csharp
using System;

delegate T MyDelegate<T>(T arg);

class Program
{
    static int Square(int x)
    {
        return x * x;
    }

    static string Reverse(string s)
    {
        return new string(s.Reverse().ToArray());
    }

    static void Main()
    {
        MyDelegate<int> intDelegate = Square;
        MyDelegate<string> stringDelegate = Reverse;

        Console.WriteLine("Square of 5: " + intDelegate(5));
        Console.WriteLine("Reverse of 'Hello': " + stringDelegate("Hello"));
    }
}
```

#### 输出
```
Square of 5: 25
Reverse of 'Hello': olleH
```

#### 说明
- `MyDelegate<T>` 是一个泛型委托，`T` 是类型参数。
- 可以为不同的类型（如 `int` 和 `string`）创建委托实例。

---

## 3. 泛型的约束
泛型约束允许你限制类型参数的范围，以确保类型参数满足特定条件。常见的约束包括：
- `where T : struct`：`T` 必须是值类型。
- `where T : class`：`T` 必须是引用类型。
- `where T : new()`：`T` 必须有一个无参构造函数。
- `where T : 基类`：`T` 必须继承自指定的基类。
- `where T : 接口`：`T` 必须实现指定的接口。

#### 示例：泛型约束
```csharp
using System;

class Calculator<T> where T : struct, IComparable<T>
{
    public T Max(T a, T b)
    {
        return a.CompareTo(b) > 0 ? a : b;
    }
}

class Program
{
    static void Main()
    {
        Calculator<int> intCalculator = new Calculator<int>();
        Console.WriteLine("Max of 3 and 5: " + intCalculator.Max(3, 5));
    }
}
```

#### 输出
```
Max of 3 and 5: 5
```

#### 说明
- `where T : struct, IComparable<T>` 约束 `T` 必须是值类型，并且实现 `IComparable<T>` 接口。

---

## 4. 泛型的优点
1. **类型安全**：编译时检查类型，避免运行时错误。
2. **代码复用**：无需为每种数据类型编写重复代码。
3. **性能优化**：避免值类型的装箱和拆箱操作。
4. **灵活性**：可以与多种数据类型一起工作。

---

## 总结
泛型是 C# 中非常重要的特性，广泛应用于集合类（如 `List<T>`、`Dictionary<TKey, TValue>`）、LINQ、委托和接口等场景。通过泛型，你可以编写更通用、更高效的代码，同时保持类型安全和代码简洁。