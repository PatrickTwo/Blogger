**笔记：对象池（Object Pool）**  

---

## 1. 定义与目的  
- **对象池**：预先分配一大块固定内存作为“池”，用于存储可重复使用的对象，取代频繁单独分配和释放对象的方式。  
- **目标**：  
  1. 提升性能（减少分配/释放开销）。  
  2. 优化内存使用，避免内存碎片（尤其在移动端、嵌入式等性能受限平台）。  

---

## 2. 背景问题  
- **内存碎片**：频繁创建和销毁大量对象会产生内存碎片，影响内存利用率与稳定性。  
- 在高性能平台影响较小，但在内存受限平台（移动端、嵌入式）弊端显著。  
- 对象池可**减少分配/释放的性能消耗**并**避免碎片化**。  

---

## 3. 设计思想与示例（子弹对象池）  
- **对象设计**：  
  - 子弹类含逻辑相关字段（如 x、y 坐标）和 `active` 布尔标记（是否有效/使用中）。  
  - `Init()`：关键方法，正确清空状态，保证复用前对象状态干净。  
  - `Update()`：更新位置，飞过一定距离后自动置为无效。  

- **对象池核心方法**：  
  - **Acquire**（获取对象）：  
    1. 在池中查找未被使用的对象 → 返回。  
    2. 若无空闲对象 → 重新分配新对象内存（示例直接 new，实际可用倍增策略）。  
  - **倍增扩容策略**（常见设计）：  
    - 初始分配 N 个对象内存，耗尽时扩容为 2N，拷贝已有对象过去。  
    - 注意：若用 STL 容器，要防止自动扩容导致指针失效；倍增策略需与容器扩容策略协调。  

---

## 4. 优点  
1. **节省创建/销毁性能开销**。  
2. **避免内存碎片**（特别是受限平台）。  
3. **提升缓存命中率**（数据局部性友好）。  
4. **集中管理内存**：便于监控内存占用与统计性能数据，避免业务代码随意分配/释放。  

---

## 5. 缺点与挑战  
1. **预分配策略难设计**：  
   - 分配过大 → 浪费内存或分配失败。  
   - 分配不足 → 频繁扩容与拷贝，反而降低性能。  
   - 需根据具体业务场景决定容量。  
2. **对象状态重置必须可靠**：  
   - 复用前需彻底清除旧状态，保证与 new 出来的对象一致。  
3. **开发成本较高**：比直接用 new 复杂，需额外管理池逻辑。  
4. **多线程安全**：需考虑并发获取对象、扩容的线程安全设计。  

---

## 6. 小结  
对象池通过**预分配 & 重复使用**对象，显著降低动态内存分配的开销与碎片化风险，适合大量短生命周期对象的场景（如子弹、粒子）。但需谨慎设计容量与状态重置逻辑，并在多线程环境下保证安全，才能发挥其性能优势。