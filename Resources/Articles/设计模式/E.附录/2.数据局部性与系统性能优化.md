**笔记：数据局部性与系统性能优化**  

---

## 1. 性能优化的误区与方向  
- **时间复杂度 ≠ 实际运行时间**：尤其游戏开发中，场景遍历等操作的时间复杂度趋近 O(n)，宏观设计比细粒度算法优化更能影响性能。  
- **瓶颈常在 IO**：CPU 性能提升快（摩尔定律），内存/显存/硬盘 IO 提升慢，IO 延迟常是性能瓶颈。  
- **关注底层计算机系统思想**：减少 CPU 与内存之间的数据交换频率，可显著提升性能。  

---

## 2. CPU 与内存的性能差距  
- **摩尔定律**：晶体管数量约每 18–24 个月翻倍 → 处理器性能约两年翻倍。  
- **内存效率提升慢**：CPU 处理速度快，但获取数据慢 → 数据供应跟不上处理能力。  
- **游戏开发常见注意点**：  
  - 避免主线程硬盘 IO 阻塞。  
  - 渲染优化减少显卡 IO 次数。  
  - 常忽略 CPU ↔ 内存 IO 代价。  

---

## 3. 缓存命中与未命中  
- **CPU 缓存机制**：CPU 不直接处理内存数据，而是将数据从内存加载到高速缓存后处理。  
- **缓存命中**：连续访问内存数据 → 所需数据已在缓存 → 避免频繁内存 IO → 高效。  
- **缓存未命中**：数据离散、指针跳转寻址 → 所需数据不在缓存 → 频繁内存 IO → 低效。  
- **数组 vs 链表**：数组内存连续，顺序访问缓存命中率高，速度更快。  

---

## 4. 面向对象代码与缓存友好性冲突  
- **面向对象特征**：抽象化、分块、解耦 → 代码易修改、接近人类思维。  
- **缓存不友好原因**：  
  - 虚表查找调用子类逻辑。  
  - 使用散落各处的指针 → 数据访问离散 → 缓存未命中率高。  

---

## 5. 提高数据局部性的设计思路  
- **组件化组织**：  
  - 将同类逻辑聚合到连续存储的组件中（如所有更新逻辑在更新组件数组，所有渲染逻辑在渲染组件数组）。  
  - 游戏对象只持有组件引用，不直接调用对象方法。  
  - 更新时遍历组件数组执行逻辑 → 数据连续 → 提高缓存命中率。  
- **与 ECS 架构的关系**：  
  - 类似但不等于 ECS；ECS 组件可设计为缓存友好（连续排布）或离散，取决于设计者。  

---

## 6. 优化注意事项  
- **不可滥用优化思想**：  
  - 缓存友好设计可能让代码更抽象，不符合直觉。  
  - 需在合适场景使用（如大量粒子对象更新）。  
- **先测量再优化**：  
  - 使用性能分析工具确认瓶颈是否由缓存未命中导致。  
  - 优化多涉及系统底层架构，宜在预见性场景提前规划，而非事后补救。  
- **适用场景**：数据局部性优化适合数据访问密集、批量处理、缓存命中收益明显的场景。