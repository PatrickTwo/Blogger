## 面向对象六大设计原则

- Single Responsibility Principle: 单一职责原则
- Open/Closed Principle：开闭原则
- Liskov Substitution Principle：里氏替换原则
- Interface Segregation Principle：接口隔离原则
- Dependency Inversion Principle：依赖倒置原则
- Law of Demeter：迪米特法则
  
### 单一职责原则（Single Responsibility Principle，SRP）
  
  要求一个类只能承担一种功能

**作用：**

- 降低耦合性：当一个类只做一件事时，出问题也容易定位和修复。
- 增强可读性和可维护性：职责单一的类结构清晰，使得后期修改和功能扩展都变得更简单。
- 复用性：拆分不同职责后，每个类都可以在其它场景中重复使用。
  
### 开闭原则（Open-Closed Principle，OCP）
  
  “对扩展开放，对修改封闭”
  当需求改变时，当我们需要改变已有的代码功能或添加新的功能模块时，应该尽量通过扩展编写新的代码，而不是修改已有代码。

**作用：**

- 预防性措施：修改已稳定的代码可能会引入新bug，扩展可以降低风险。
- 提高灵活性：在游戏开发等需求多变的领域，通过扩展方式可以更好地应对需求变化。
  
### 里氏替换原则（Liskov Substitution Principle，LSP）
  
  要求所有父类出现的地方，都可以使用子类对象来替换，而不会改变程序的正确性
  子类是父类的更具象的描述，而遵循与父类相同的功能

**作用：**

- 保证继承体系的正确性：若子类未完全遵循父类契约，调用者可能遭遇意外问题。
- 提高代码复用性：符合LSP的设计可让多态机制充分发挥效用，增强系统扩展性。

**具体实现要求**

+ 子类方法的参数类型必须与其父类的参数类型相匹配或更加抽象
+ 子类方法的返回值类型必须与父类方法的返回值类型或是其子类别相匹配
+ 子类中的方法不应抛出基础方法预期之外的异常类型
+ 子类不应该加强其前置条件
+ 子类不能削弱其后置条件
+ 父类的不变量必须保留
+ 子类不能修改父类中私有成员变量的值
  
### 接口隔离原则（Interface Segregation Principle，ISP）

“拆”，将一个大而全的通用接口，拆分设计成更小的，关注点更精确的细分接口

### 依赖倒置原则（Dependency Inversion Principle，DIP）

高层次（上层业务）的类不应该依赖低层次（底层架构）的类，要将二者的依赖转嫁到抽象接口之上

### 迪米特法则（Law of Demeter，LOD）（最少知识原则）

要求一个对象只与其直接关联的对象进行通信，而不会与陌生对象产生耦合
这是避免出现链式调用和间接依赖的关键
  作用：
- 降低耦合度：减少对象之间的依赖，防止因某个对象的变化影响过多其他对象。
- 增强系统稳定性：每个模块只关注自己的直接关系，便于测试和维护。

## 设计模式分类

### 创建型模式
1. 工厂方法模式（Factory Method Pattern）
2. 抽象工厂模式（Abstract Factory Pattern）
3. 单例模式（Singleton Pattern）
4. 建造者模式（Builder Pattern）
5. 原型模式（Prototype Pattern）
### 结构型模式
1. 适配器模式（Adapter Pattern）
2. 桥接模式（Bridge Pattern）
3. 组合模式（Composite Pattern）
4. 装饰模式（Decorator Pattern）
5. 外观模式（Facade Pattern）
6. 享元模式（Flyweight Pattern）
7. 代理模式（Proxy Pattern）
### 行为型模式
1. 策略模式（Strategy Pattern）
2. 模板方法模式（Template Method Pattern）
3. 观察者模式（Observer Pattern）
4. 迭代器模式（Iterator Pattern）
5. 责任链模式（Chain of Responsibility Pattern）
6. 命令模式（Command Pattern）
7. 状态模式（State Pattern）
8. 备忘录模式（Memento Pattern）
9. 访问者模式（Visitor Pattern）
10. 中介者模式（Mediator Pattern）