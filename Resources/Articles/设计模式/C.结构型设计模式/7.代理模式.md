**笔记：代理模式（Proxy Pattern）**  

- **定义**  
  代理模式创建一个代理层，代替客户端访问原始对象。代理是原始对象的替代品或占位符，可在请求经处理后传递给原始对象。  

- **核心思想**  
  在不改变原始对象接口的前提下，引入代理控制访问、管理生命周期、添加额外逻辑。  

- **沙盒游戏区块加载案例**  
  1. **服务接口 IChunk**：规定区块功能（`Load`、`Render`）。  
  2. **实际服务 RealChunk**：实现接口，保存坐标，执行真实加载与渲染逻辑。  
  3. **代理 ProxyChunk**：同样实现接口，持有 RealChunk 引用；调用前检查是否已实例化，未实例化则先创建；渲染前确保实例存在才调用真实渲染。  
  4. 客户端只与 ProxyChunk 交互，不直接实例化 RealChunk。  
  5. 代理可封装卸载等资源管理逻辑，使 RealChunk 专注业务，客户端使用无感知。  

- **关键组成要素**  
  1. **服务接口**：定义功能契约，代理与实际服务均遵循。  
  2. **实际服务**：提供业务逻辑，可不感知代理存在。  
  3. **代理**：持有实际服务对象，管理其生命周期，在接口方法中先做检查/校验，再转发请求。  

- **经典应用场景**  
  1. **延时加载**：大型开放世界地图区块动态加载。  
  2. **缓存**：资源代理判断缓存是否存在，避免频繁加载纹理、音频、模型。  
  3. **权限控制**：购买道具检验金币、升级技能检验经验值。  
  4. **远程代理**：RPC 调用伪装成本地对象调用，简化网络通信。  
  5. **智能代理**：日志记录、性能监控与分析。  

- **优点**  
  1. 客户端无感知控制实际服务对象。  
  2. 代理可管理生命周期，自动创建/释放资源。  
  3. 代理可作占位符，在实际服务未准备好时仍能工作，甚至先完成任务或缓存后交付。  

- **缺点**  
  1. 增加类与代码量，排查问题时需考虑代理层。  
  2. 可能引入延迟响应（资源异步加载、网络调用），需队列缓存请求。