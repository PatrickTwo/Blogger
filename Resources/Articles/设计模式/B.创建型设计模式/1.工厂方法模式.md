## 一、创建型设计模式概述
创建型设计模式关注对象创建过程，提供更多机制和步骤，能提升项目代码的灵活性和可复用性。

创建型设计模式主要包括:
 - 工厂方法模式：在父类中提供一个创建对象的接口，让子类决定具体实例化什么类型的对象。
 - 抽象工厂模式：可以看作工厂方法模式多一个维度的扩展。
     > 工厂方法模式通常用来创建一类产品，而抽象工厂模式用来创建一系列相关的产品。
 - 建造者模式（生成器模式）：通常应用在复杂对象的构造中，把对象构造的逻辑从他本身的类中抽离出来，让专门的生成器来负责。
 - 原型设计模式：提供了无依赖的对象复制，可以在不了解对象内部细节的情况下对它进行拷贝。
 - 单例模式：可以看作是全局属性的一种面向对象的管理策略，确保单例类只能有一个实例，并且提供了一个可以访问这个对象的全局节点。

## 二、工厂方法模式
1. **概念**
    - 在父类中提供一个创建对象的接口，让子类决定具体实例化什么类型的对象。
2. **应用场景示例**
    - 游戏中玩家可选择多种武器和装备，每个武器和道具都有不同属性、功能和品质等私有字段。借助武器装备道具工厂对象，根据游戏状态或玩家操作动态创建具体装备对象。
    - 以武器为例，定义武器基类 `weapon`，有一个纯虚方法 `use` 代表使用武器的逻辑，派生出剑和弓等子类，各有自己的使用逻辑。不使用设计模式时，子类可直接实例化和使用；使用工厂方法模式时，创建工厂基类，约定所有生成具体武器的工厂都实现 `createWeapon` 方法对外返回创建后的对象，再实现具体的工厂子类，如生产剑的工厂和生产弓的工厂，通过具体工厂对象创建对应武器产品。
3. **关键要素**
    - **抽象产品**：如武器基类，是后续所有创建者及其子类构建对象的通用声明。
    - **具体产品**：如剑和弓等具体武器对象，是抽象产品接口的不同实现。
    - **抽象工厂（创建者）**：不直接进行具体产品创建，负责对创建的接口进行声明，后续所有创建者返回的对象类型都必须与产品接口相匹配。
    - **具体工厂**：负责重写抽象工厂的方法，实例化不同的具体产品对象并返回。
4. **优势**
    - **实现客户端与具体产品类的解耦**：在游戏开发中，玩家类只需依赖具体的工厂类，无需关注产品类内部实现或构造需求，可独立变更与角色控制相关的玩家类和实现具体功能玩法的武器道具类，对大型项目协作开发尤为重要。
    - **提高系统的可扩展性**：游戏中出现新的武器（新产品）时，只需创建新的具体工厂类，无需改变角色代码或已有的工厂方法。
    - **封装复杂对象的创建逻辑**：实际项目中具有特定功能的游戏对象往往需遵循一定规则进行构造和初始化，工厂类可将这些任务屏蔽在自身内部，无需让玩家角色类关注。
    - **遵循面向对象的开闭原则和单一职责原则**：可轻松扩展而无需修改已有内容，武器的创建和使用分属不同步骤和职责，应拆分到不同类中管理。
    - **集中产品对象创建逻辑**：把产品对象所有的创建逻辑集中到一起，避免将武器对象的构造和初始化散落在玩家类各处，方便统一管理，需求变更时无需在玩家逻辑内部到处翻找代码。
    - **创建不同的产品组**：如跨平台的 GUI 应用，不同平台分属于不同的工厂家族，每个工厂家族中又有按钮、文本框等不同产品，相关逻辑在抽象工厂模式中会更细致讲述。
5. **实际应用场景**
    - **日志系统**：大型项目中，不同级别的日志常需不同的输出接口（如打印到控制台、输出到文件、通过网络传输远程监控调试、存储到数据库等），通过工厂方法模式，无需关心日志的具体输出逻辑，通过工厂的统一接口管理日志输出对象。
    - **数据库的连接驱动**：不同应用场景或设备环境下，需将应用连接到不同的数据库，可通过工厂方法获取数据库连接，无需关注具体的数据库类型，还可通过配置文件、环境变量等动态感知选择不同的数据库。
    - **文档生成**：大型系统的文档手册通过自动化工具配合注释自动化生成导出，通过对具体导出工具对象的屏蔽，可灵活实现 HTML 或 markdown 等不同格式的文档文件。
6. **缺点**
    - 添加了工厂层的抽象，引入过多的类，在对简单系统、简单对象的创建时有过度设计的嫌疑。
    - 过多的工厂类会掩盖整个系统的创建逻辑，不利于阅读和理解。
    - 单独的工厂方法模式在面对存在组合关系的产品时，显得不够灵活，需要使用抽象工厂模式。