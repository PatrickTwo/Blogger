**笔记：状态模式（State Pattern）**  

---

## 1. 定义与核心理念  
- **学术定义**：允许对象在内部状态改变时改变它的行为。  
- **通俗理解**：对象内部状态变化时，其行为像“换了类”一样发生变化。  
- **来源**：基于**状态机**（State Machine）理念抽象而来，用于处理对象在不同状态下的不同逻辑。  

---

## 2. 游戏经典场景：玩家角色行为控制  
玩家有多种状态（闲置、奔跑、跳跃、翻滚闪避等），不同状态下属性与功能不同。  
例如：翻滚闪避状态 → 短暂无敌。  

---

## 3. 模式结构与代码示例（简化版）  

### 3.1 状态接口 `IState`  
- 所有具体状态子类必须实现 `Handle()` 方法，执行对应状态下的逻辑。  

```cpp
class IState {
public:
    virtual void Handle() = 0;
    virtual ~IState() {}
};
```

### 3.2 上下文 `Player`（环境/角色类）  
- 持有当前状态对象的引用。  
- 提供 `ChangeState(IState* state)` 接口切换状态。  
- `Request()` 方法调用当前状态的 `Handle()`，将逻辑委托给状态对象。  

```cpp
class Player {
private:
    IState* currentState;
public:
    void ChangeState(IState* state) {
        currentState = state;
    }
    void Request() {
        if (currentState) currentState->Handle();
    }
};
```

### 3.3 具体状态类  
示例：健康、受伤、死亡三种状态（仅用 `std::cout` 输出不同内容）。  

```cpp
class HealthyState : public IState {
public:
    void Handle() override {
        std::cout << "Player is healthy." << std::endl;
    }
};

class InjuredState : public IState {
public:
    void Handle() override {
        std::cout << "Player is injured." << std::endl;
    }
};

class DeadState : public IState {
public:
    void Handle() override {
        std::cout << "Player is dead." << std::endl;
    }
};
```

### 3.4 客户端  
- 创建 `Player`（上下文）。  
- 通过 `ChangeState()` 传入不同状态对象切换状态。  
- 调用 `Request()` 执行当前状态逻辑。  

```cpp
Player player;
player.ChangeState(new HealthyState());
player.Request(); // 输出 healthy

player.ChangeState(new InjuredState());
player.Request(); // 输出 injured

player.ChangeState(new DeadState());
player.Request(); // 输出 dead
```

---

## 4. 构成要素  
1. **状态接口**：统一所有具体状态的 `Handle()` 行为。  
2. **具体状态子类**：实现不同状态下的行为逻辑，可进一步用继承细分。  
3. **上下文（Context）**：持有当前状态引用，负责状态切换与调用状态行为。  
   - 状态切换可由上下文控制，也可由具体状态通过上下文暴露的接口实现跳转。  

---

## 5. 优点  
1. **简化代码**：避免大量 `if-else` / `switch-case` 判断，逻辑分散到各状态类。  
2. **易于扩展**：新增状态只需添加新的状态子类，无需修改上下文或其他状态类（符合**开闭原则**）。  
3. **单一职责**：每个状态封装自身行为与相关数据，避免逻辑与数据混杂，不破坏封装性。  
4. **可读性与维护性提升**：状态逻辑清晰分离，排错与后续更新更容易。  

---

## 6. 应用场景  
- **玩家角色控制**：不同状态对应不同动作与属性（移动、攻击、闪避、死亡等）。  
- **敌人 AI**：进攻、防守、追逐、巡逻等策略状态。  
- **任务流程**：复杂任务分多个阶段子任务，每阶段有不同完成条件与处理逻辑。  

---

## 7. 小结  
状态模式将对象的状态与行为绑定在一起，通过切换状态对象来改变行为，使代码更符合面向对象设计原则，特别适合有明显状态转移需求的系统（如游戏角色、AI、工作流）。  