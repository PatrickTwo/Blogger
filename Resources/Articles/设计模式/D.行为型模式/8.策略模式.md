#### **一、策略模式核心定义与类比**  
- **核心思想**：将**算法和处理策略封装成对象**，使策略可独立于使用它的上下文“即插即用”，便于根据上下文环境灵活切换。  
- **类比记忆**：  
  - 与命令模式对比：命令模式封装“指令行动”（方便记录/回溯），策略模式封装“算法策略”（方便动态切换）；  
  - 与状态模式对比：均基于组合模式思想，将工作任务委派给其他对象，但状态模式侧重“状态驱动的自动切换”，策略模式侧重“主动选择策略”；  
  - 与命令模式共性：均将行为保存到对象中，但命令模式常保存详细命令参数，策略模式行为更纯粹（仅响应外部数据处理）。  


#### **二、策略模式经典案例：排序算法切换**  
##### 1. 问题背景  
需对一组数据排序，不同场景（数据量、错乱程度）下，冒泡/堆排/快排等算法各有优劣，需用面向对象思想优雅切换算法。  


##### 2. 实现步骤  
- **① 策略接口**：定义排序策略的统一接口（如`SortStrategy`），声明排序方法（示例中输入`vector`引用，支持原地修改数据）。  
- **② 具体策略类**：实现接口的具体算法类（如`BubbleSortStrategy`、`QuickSortStrategy`），专注于自身算法逻辑（示例中简化为输出文本模拟排序过程）。  
- **③ 上下文类（排序器）**：存储当前排序策略，提供“设置策略”“执行排序”的方法——客户端通过上下文调用策略，无需直接与具体策略交互。  


##### 3. 客户端使用  
构造排序器→设置不同策略（如先设冒泡、再设快排）→输入目标数据→执行排序，实现算法便捷切换。  


#### **三、策略模式构成要素**  
1. **策略接口**：定义所有具体策略的共有方法（如`sort(vector&)`），确保客户端一致对待不同策略。  
2. **具体策略**：实现接口的类，封装特定算法逻辑（如冒泡/快排的具体步骤）。  
3. **上下文**：持有策略对象，负责接收输入数据、调用策略方法；实际中，输入数据也可存储在上下文中（不仅是“存储策略的工具”）。  


#### **四、策略模式 vs 其他模式辨析**  
- **与状态模式**：均基于组合模式委派任务，但状态模式是“状态自动触发策略切换”（如订单状态流转），策略模式是“主动选择策略”（如手动切换排序算法）。  
- **与命令模式**：均封装行为，但命令模式侧重“指令的记录/回溯”（如操作日志），策略模式侧重“算法动态替换”（如排序算法切换）。  
- **与设计模式本质**：模式是“组织代码的配方”，非死规则，需关注“优雅解决问题”，不必过度纠结模式标签。  


#### **五、游戏开发中的应用：AI差异化策略**  
- **典型场景**：同类型角色的差异化行为设计（如《吃豆人》中4个敌对精灵的追逐策略不同：随机游走、最短路径追击、激进追击、保守步步为营）。  
- **核心价值**：通过策略模式为同类角色赋予不同行为逻辑，丰富游戏体验，避免重复定义角色类（如无需为4种精灵写4个类，只需4种策略+1个基类角色）。  


#### **六、后续关联**  
- 对比“模板方法模式”：另一种基于继承的行为切换模式，但工程要素更少（无显式策略接口/上下文）；  
- 下期内容：通过代码项目实战策略模式在AI中的具体应用。  


**总结**：策略模式通过“封装算法为对象”实现灵活切换，核心是“策略接口+具体策略+上下文”，在排序、AI差异化等场景中大幅降低耦合，提升扩展性。