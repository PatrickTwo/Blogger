**笔记：迭代器模式（Iterator Pattern）**  

- **定义**  
  在不暴露底层数据结构的情况下，提供一种统一的方式来遍历集合中的所有元素。核心是**将遍历逻辑与集合实现分离**，客户端通过统一接口访问元素。  

- **核心思想**  
  屏蔽不同数据结构（数组、链表、树等）的差异，对外提供一致的遍历接口，便于在需求变化时切换存储结构而不影响客户端代码。  

- **游戏场景示例：遍历游戏单位**  
  1. **迭代器接口 `Iterator`**  
     - `HasNext()`：判断是否还有下一个元素。  
     - `Next()`：获取下一个元素，并推进迭代器内部索引。  
     - 示例中用 `string` 表示元素类型，实际项目中常用基类指针（如 `GameObject*`）。  

  2. **具体迭代器 `ConcreteIterator`**  
     - 内部持有目标集合的引用（如 `vector<string>`）和当前索引 `index`。  
     - `HasNext()` 检查 `index` 是否越界。  
     - `Next()` 返回当前元素并递增 `index`（一行代码完成取值与推进）。  
     - 迭代进度保存在迭代器对象本身（非 static），允许多个迭代器同时遍历同一集合。  

  3. **集合接口 `Collection`**  
     - 定义 `CreateIterator()` 方法，返回对应迭代器。  
     - 抽象出“可遍历”的能力，与具体数据结构解耦。  

  4. **具体集合 `ConcreteCollection`**  
     - 内部用 `vector<string>` 存储单位名称（实际可用 `vector<GameObject*>`）。  
     - `CreateIterator()` 创建具体迭代器并传入内部容器引用。  
     - 元素可通过其他接口动态添加。  

  5. **客户端代码**  
     - 创建集合 → 获取迭代器 → 用 `while (iterator.HasNext()) { element = iterator.Next(); }` 遍历。  
     - 无需关心底层是 `vector`、链表还是其他结构，代码简洁统一。  

- **构成要素**  
  1. **Iterator（迭代器）**：定义遍历接口。  
  2. **ConcreteIterator（具体迭代器）**：实现遍历逻辑，维护遍历状态。  
  3. **Collection（集合接口）**：定义创建迭代器的方法。  
  4. **ConcreteCollection（具体集合）**：实现集合存储，返回对应迭代器。  

- **重要细节**  
  - 迭代器内部状态（如 `index`）是每个迭代器对象独有的，不能共享（避免多个遍历互相干扰）。  
  - 一个集合可提供多种迭代器（正序、倒序、条件过滤等），满足不同遍历需求。  

- **优点**  
  1. **隐藏集合内部实现细节**，防止外部直接修改导致安全问题。  
  2. **减少客户端代码量**，避免遍历逻辑与业务代码混杂，提高可读性。  
  3. **解耦集合与遍历逻辑**，同一套客户端代码可用于不同数据结构或未来未知结构。  
  4. **支持多种遍历方式**（正序、倒序、筛选），灵活扩展。  

- **应用场景**  
  - 游戏单位管理、UI 控件列表、关卡对象集合等需要统一遍历的场景。  
  - 数据结构可能变化或需要多种遍历方式的系统。  
