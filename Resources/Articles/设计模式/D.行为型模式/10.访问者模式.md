**笔记：访问者模式（Visitor Pattern）**  

- **定义**  
  将算法与它的作用对象隔离开，把原本属于类的成员方法中的部分逻辑移到类外部的独立访问者中实现，从而在不修改对象结构的前提下新增操作。  

- **核心思想**  
  把作用于一组对象上的多种不同操作（算法）集中到访问者中，通过“双重分发”机制（对象接受访问者，访问者访问对象）实现操作与对象的解耦。  

- **游戏场景示例：攻击/交互不同游戏对象**  
  1. **元素接口 `Element`**  
     - 定义 `Accept(Visitor* visitor)` 方法，所有可被访问的游戏对象均需实现。  
  2. **具体元素类**  
     - `Monster`：含 `health`（int）等字段；`Accept` 中调用 `visitor->Visit(this)`。  
     - `TreasureChest`：含 `isLocked`（bool）等字段；`Accept` 中调用 `visitor->Visit(this)`。  
     - （示例中字段为 public，便于访问者直接读写，实际会牺牲封装性）  
  3. **访问者接口 `Visitor`**  
     - 为每种具体元素提供重载的 `Visit` 方法：`Visit(Monster* m)`、`Visit(TreasureChest* t)`。  
  4. **具体访问者 `AttackVisitor`**  
     - `Visit(Monster*)`：怪物生命值减 20 并输出剩余血量。  
     - `Visit(TreasureChest*)`：修改宝箱锁定状态（打开逻辑）。  
  5. **对象结构 `GameWorld`**  
     - 持有 `vector<Element*> elements`，提供 `ApplyVisitor(Visitor* v)` 遍历并调用每个元素的 `Accept(v)`。  
  6. **客户端**  
     - 创建游戏世界并添加元素 → 创建访问者 → 调用 `ApplyVisitor` 执行操作 → 各元素按访问者逻辑响应。  

- **构成要素**  
  1. **Visitor（访问者接口）**：声明对不同元素的访问方法。  
  2. **ConcreteVisitor（具体访问者）**：实现针对各元素的具体操作逻辑。  
  3. **Element（元素接口）**：声明 `Accept(Visitor)` 方法。  
  4. **ConcreteElement（具体元素）**：实现 `Accept`，并在方法中调用访问者的对应 `Visit`。  

- **优点**  
  1. **符合开闭原则**：新增操作（算法）只需新增访问者，不必修改元素类。  
     - 例：《我的世界》三叉戟可新增“投掷”访问者，无需改三叉戟类。  
  2. **相关行为集中**：同类操作集中在同一访问者，代码更易读、易维护。  

- **缺点**  
  1. **破坏封装性**：访问者需直接访问元素内部数据（常需公开字段）。  
  2. **元素类变更成本高**：新增/修改元素需在所有访问者中增加/调整对应 `Visit` 方法。  
  3. **增加系统复杂度**：双重分发与接口膨胀使结构不易理解。  

- **游戏开发典型应用**  
  1. **道具/技能效果**：不同技能对角色、建筑、环境产生不同效果，用访问者避免在各对象内写大量条件判断。  
  2. **物理引擎处理**：刚体/触发器属性与碰撞处理算法分离，逻辑集中易扩展。  
  3. **业务系统**：任何需要对一组异构对象执行多种不同操作且操作易变的场景。  

- **小结**  
  访问者模式适用于**对象结构稳定、操作易变**的情况，能将分散的操作逻辑集中管理，提升可维护性，但需权衡封装性与扩展性。