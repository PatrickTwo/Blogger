**笔记：中介者模式（Mediator Pattern）**  

- **目的**  
  解决对象之间混乱无序的依赖关系，限制对象彼此直接交互，强迫它们通过**中介者对象**进行合作与通信，打破“通信双方必须相互依赖”的紧耦合问题。  

- **核心思想**  
  引入第三方中介者统一管理对象间的交互，使对象之间不再直接引用彼此，降低耦合度，集中控制通信逻辑。  

- **示例场景：多人聊天室**  
  1. **抽象中介者接口 `IMediator`**  
     - 定义通知方法（如 `SendMessage(msg, target)`），参数一般为消息内容与目标对象。  
     - 接口应保持简单，不规定复杂行为。  
  2. **同事类抽象 `Colleague`**  
     - 抽象类，定义 `Receive(msg)` 接口供具体同事实现接收消息逻辑。  
     - 构造函数中注入并保存中介者引用，用于发送消息。  
  3. **具体中介者 `ChatRoom`**  
     - 持有所有同事对象的集合（如 `vector<Colleague*>`）。  
     - 提供 `AddColleague()` 方法向集合中添加同事。  
     - 实现 `SendMessage()`：遍历集合，将消息发送给除发送者外的所有同事（广播）。  
  4. **具体同事 `User`**  
     - 拥有名字标识，构造时注入中介者。  
     - 发送消息时调用中介者的 `SendMessage()`，不直接调用其他同事方法。  
     - 接收消息时输出收到的内容。  
  5. **客户端**  
     - 创建中介者（聊天室）→ 创建多个同事（用户）并注入中介者 → 调用用户的发送方法，实现群聊。  
     - 成员之间没有直接调用，通信由中介者完成，避免耦合。  

- **构成要素**  
  1. **抽象组件（Colleague）**：定义同事类的通用接口与中介者引用。  
  2. **具体组件（ConcreteColleague）**：实现具体业务与接收消息逻辑。  
  3. **抽象中介者（IMediator）**：定义对象间交互的统一接口（通常仅一个通知方法）。  
  4. **具体中介者（ConcreteMediator）**：持有各组件引用，管理交互与生命周期，实现通信逻辑。  

- **与代理模式的区别**  
  - **代理模式**（结构型）：控制对目标对象的直接访问，实现缓存、延时加载、权限控制等；示例——大世界区块加载/卸载。  
  - **中介者模式**（行为型）：解决多个对象间的通信耦合问题，抽象出中介者统一管理交互。  
  - 代理是“访问控制”，中介者是“通信协调”。  

- **与观察者模式/消息总线的关系**  
  - 均为消息传递与通信机制，但实现理念与应用场景不同，留待观察者模式章节详析。  

- **优点**  
  - 降低对象间耦合，避免网状依赖。  
  - 集中管理交互逻辑，易于维护和扩展。  
  - 中介者可管理组件生命周期与状态。  

- **适用场景**  
  - 多对象需频繁交互且直接引用会导致高耦合的系统（如聊天室、GUI 组件协作、游戏实体协作）。