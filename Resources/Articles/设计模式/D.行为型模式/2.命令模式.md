**笔记：命令模式（Command Pattern）**  

- **定义**  
  将请求封装成包含请求相关所有信息的独立对象，可将方法参数化、延迟执行、入队，支持撤销/重做。本质是把对方法的调用行为转化为对象保存，是实现撤销重做机制的核心设计模式。  

- **核心思想**  
  将无形的动作实体化为可存储、传递、执行的对象，实现行为与调用者的解耦。  

- **示例场景：遥控器控制灯**  
  1. **接收者 Light**：包含实际业务逻辑，提供 `On()`、`Off()`、`AdjustBrightness(level)` 接口。  
  2. **命令接口 Command**：定义统一 `Execute()` 方法。  
  3. **具体命令**：  
     - `LightOnCommand` / `LightOffCommand`：在构造函数中保存 Light 引用，`Execute()` 调用对应方法。  
     - `LightAdjustBrightnessCommand`：构造函数可带额外参数（亮度值），演示不同命令可拥有不同构造保存更多数据，只要 `Execute()` 接口统一。  
  4. **发送者 Invoker（遥控器）**：持有 Command 对象，触发 `Execute()` 执行命令。  
  5. **客户端**：创建接收者 → 创建具体命令（注入接收者） → 将命令设置到发送者 → 通过发送者执行命令。可用数组/队列存储命令实现批量或延迟执行。  

- **构成要素**  
  1. **接收者（Receiver）**：实现具体业务逻辑，命令调用其接口完成工作。  
  2. **命令接口（Command）**：规定所有命令必须实现的 `Execute()` 方法。  
  3. **具体命令（ConcreteCommand）**：在 `Execute()` 中调用接收者相应方法，可保存不同参数。  
  4. **发送者/触发者（Invoker）**：持有命令对象并触发执行。  

- **经典应用场景**  
  1. **记录与重放**：编辑器撤销/重做（每步操作封装为命令存入栈），游戏场景回放、对局重放。  
  2. **联机游戏操作同步**：本地输入经引擎转为事件 → 封装为命令 → 序列化发送至服务器，保持行为与表现解耦。  
  3. **任务调度系统**：将用户交互或任务封装为命令独立执行，确保框架与业务逻辑解耦。  

- **优点**  
  1. **解耦发送者与接收者**：可在不同层级或设备，发送者无需知晓接收者实现细节。  
  2. **命令参数化**：行为实体化为对象，可存储、转发、排队。  
  3. **支持撤销/重做**：基于参数化命令实现增量状态还原。  
  4. **可扩展性强**：新增命令无需改动现有接收者、发送者和其他命令，只需实现新命令类。